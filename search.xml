<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>读记力扣《图解算法数据结构》：数据结构简介</title>
      <link href="202103/illustration-of-algorithm-1/"/>
      <url>202103/illustration-of-algorithm-1/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202103/illustration-of-algorithm-1/cover.png" class="" width="0" height="0"><h1 id="我对算法的认识-👀"><a href="#我对算法的认识-👀" class="headerlink" title="我对算法的认识 👀"></a>我对算法的认识 👀</h1><p>算法算是大多数程序员头裂 😖 的一门功课了，日常的工作中应用场景算是比较少的，特别是对于前端工程师来说，几乎不存在服务端将上千、上万条数据交予你查出最大，最佳组合，过滤等各种操作等。<br>以前的我也一直不理解算法学习的意义在哪里？<br>我的学习习惯是需要实践才可以记得，所以以前也尝试着去学习算法，但看了头裂，就算做出了部分题后，或看了题解等，过没一两天就忘记了，没有应用的场景或对算法的执爱，会对算法知识难以下手学习，我甚至在知乎也搜过相关的问题，因为现下求职市场的硬性标准，也开始好奇企业对面试一节中对算法的一个看法与认识；在看过众多答案中，印象深刻的一个看法加上自己的理解是：</p><ul><li>算法在面试中的作用主要是了解你对程序逻辑、数据结构、所学语言、思维能力、冷静思考、甚至是代码风格的一个过程，就好像前端角度来说，你对 HTML 的结构与 CSS 规则的理解认识与运用的更好，程序任务的运行的效率就越高。</li><li>算法可以当成一个脑筋急转弯的锻炼，通过每天一题，让大脑保持活跃的思考中，也慢慢的善于思考，在 LeetCode 中看题解中，总可以看到高手的解答是让人心驰神往，是怎样一个思维敏捷的大脑写出如此机智的答案。抛开天赋，我相信也只有坚持不懈的练习，才有可能慢慢拥有这样的 🧠 思维敏捷。</li><li>算法就像学武功前的马步等基本功，枯燥且令人浮躁且不解；就算没有扎实的基本功，还是可以打出个一两式，写出几个项目，只是功夫上速度、底盘皆弱于有练之人，项目中上对项目的优化未及有练之人；更重要的是磨练心性，冷静且精神力强大。🦾</li></ul><p>在每日一题之前，会发现如数据结构和常见的算法公式基础知识的不足，相对还是难以理解融会贯通的运用算法做题的，所以也希望可以通过阅读笔记+实践，更加牢固的理解相关的知识。</p><blockquote><p>此次书籍来自 LeetCode 学习中《图解算法数据结构》网络书籍：<br>书籍地址：<a href="https://leetcode-cn.com/leetbook/detail/illustration-of-algorithm/">https://leetcode-cn.com/leetbook/detail/illustration-of-algorithm/</a></p></blockquote><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>数据的结构在算法中起着至关重要的作用，不同的数据结构都有自己的适用场景；旨在降低各种算法中的时间与空间的复杂度，达到最佳的任务执行效率。</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202103/illustration-of-algorithm-1/struc_mind.png" class="center" width="500"><ul><li><h2 id="线性数据结构"><a href="#线性数据结构" class="headerlink" title="线性数据结构"></a>线性数据结构</h2><ul><li><h3 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 Array"></a>数组 Array</h3><p>数组是将相同类型的元素存储于连续内存空间的数据结构，一般其长度不可变，前端认识到的数组一般是长度可变的数组</p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 初始化一个的数组 array 并赋值</span><br><span class="hljs-keyword">let</span> array: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202103/illustration-of-algorithm-1/array.png" class="center" width="500"></li><li><h3 id="链表-Chain"><a href="#链表-Chain" class="headerlink" title="链表 Chain"></a>链表 Chain</h3><p>链表以节点为单位，每个元素都是一个独立对象，在内存空间的存储是非连续的。</p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chain</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">public</span> value: T; <span class="hljs-comment">// 节点值</span><br>  <span class="hljs-keyword">public</span> next: Chain&lt;T&gt;; <span class="hljs-comment">// 后继节点引用</span><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">v: T</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.value = v;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> n1: Chain&lt;<span class="hljs-built_in">number</span>&gt; = <span class="hljs-keyword">new</span> Chain&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">4</span>); <span class="hljs-comment">// 节点 head</span><br><span class="hljs-keyword">let</span> n2: Chain&lt;<span class="hljs-built_in">number</span>&gt; = <span class="hljs-keyword">new</span> Chain&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">let</span> n3: Chain&lt;<span class="hljs-built_in">number</span>&gt; = <span class="hljs-keyword">new</span> Chain&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 构建引用指向</span><br>n1.next = n2;<br>n2.next = n3;<br></code></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202103/illustration-of-algorithm-1/chain.png" class="center" width="500"></li><li><h3 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 Stack</h3><p>栈是一种具有 「先入后出」 特点的抽象数据结构，可使用数组或链表实现。</p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">public</span> list: T[];<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.list = [];<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">push</span>(<span class="hljs-params">v: T</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.list.push(v);<br>  &#125;<br>  <span class="hljs-keyword">public</span> pop(): T &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.list.pop();<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> stack: Stack&lt;<span class="hljs-built_in">number</span>&gt; = <span class="hljs-keyword">new</span> Stack&lt;<span class="hljs-built_in">number</span>&gt;(); <span class="hljs-comment">// 节点 head</span><br>stack.push(<span class="hljs-number">1</span>);<br>stack.push(<span class="hljs-number">2</span>);<br>stack.pop(); <span class="hljs-comment">// -&gt; 2</span><br>stack.pop(); <span class="hljs-comment">// -&gt; 1</span><br></code></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202103/illustration-of-algorithm-1/stack.png" class="center" width="500"></li><li><h3 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 Queue"></a>队列 Queue</h3><p>队列是一种具有 「先入先出」 特点的抽象数据结构，可使用数组或链表实现。</p><figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">public</span> list: T[];<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.list = [];<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">push</span>(<span class="hljs-params">v: T</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.list.push(v);<br>  &#125;<br>  <span class="hljs-keyword">public</span> dequeue(): T &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.list.shift();<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> queue: Queue&lt;<span class="hljs-built_in">number</span>&gt; = <span class="hljs-keyword">new</span> Queue&lt;<span class="hljs-built_in">number</span>&gt;(); <span class="hljs-comment">// 节点 head</span><br>queue.push(<span class="hljs-number">1</span>);<br>queue.push(<span class="hljs-number">2</span>);<br>queue.dequeue(); <span class="hljs-comment">// -&gt; 1</span><br>queue.dequeue(); <span class="hljs-comment">// -&gt; 2</span><br></code></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202103/illustration-of-algorithm-1/queue.png" class="center" width="500"></li></ul></li><li><h2 id="非线性数据结构"><a href="#非线性数据结构" class="headerlink" title="非线性数据结构"></a>非线性数据结构</h2><ul><li><h3 id="树-Tree"><a href="#树-Tree" class="headerlink" title="树 Tree"></a>树 Tree</h3><p>根据子节点数量可分为 「二叉树」 和 「多叉树」，最顶层的节点称为「根节点 root」。</p><figure class="highlight typescript"><figcaption><span>二叉树 TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">public</span> value: T; <span class="hljs-comment">// 节点值</span><br>  <span class="hljs-keyword">public</span> left: TreeNode&lt;T&gt;; <span class="hljs-comment">// 后继节点引用</span><br>  <span class="hljs-keyword">public</span> right: TreeNode&lt;T&gt;; <span class="hljs-comment">// 后继节点引用</span><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">v: T</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.value = v;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> n1: TreeNode&lt;<span class="hljs-built_in">number</span>&gt; = <span class="hljs-keyword">new</span> TreeNode&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">3</span>); <span class="hljs-comment">// 根节点 root</span><br><span class="hljs-keyword">let</span> n2: TreeNode&lt;<span class="hljs-built_in">number</span>&gt; = <span class="hljs-keyword">new</span> TreeNode&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">4</span>);<br><span class="hljs-keyword">let</span> n3: TreeNode&lt;<span class="hljs-built_in">number</span>&gt; = <span class="hljs-keyword">new</span> TreeNode&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">let</span> n4: TreeNode&lt;<span class="hljs-built_in">number</span>&gt; = <span class="hljs-keyword">new</span> TreeNode&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">let</span> n5: TreeNode&lt;<span class="hljs-built_in">number</span>&gt; = <span class="hljs-keyword">new</span> TreeNode&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// 构建引用指向</span><br>n1.left = n2;<br>n1.right = n3;<br>n2.left = n4;<br>n2.right = n5;<br></code></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202103/illustration-of-algorithm-1/tree.png" class="center" width="500"></li><li><h3 id="图-Graph"><a href="#图-Graph" class="headerlink" title="图 Graph"></a>图 Graph</h3><p>图由「节点（顶点）vertex」和「边 edge」组成，每条边连接一对顶点。根据边的方向有无，图可分为「有向图」和「无向图」。</p><blockquote><p>图 Graph 数据结构属于非常复杂的非线性数据结构，这里只简单先看一下，详细的 数据结构特点、应用场景、算法后续再继续深入的学习实践与了解<br>书籍也先简单以 <strong>以无向图为例</strong> 开展介绍</p></blockquote><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202103/illustration-of-algorithm-1/graph.png" class="center" width="500"><ul><li><p>表示图的方法通常有两种：</p><ol><li><p><strong>邻接矩阵</strong>：使用数组 \(vertices\) 存储顶点，矩阵 \(edges\) 存储边；\(edges[i][j]\) 代表着节点 \(i+1\) 与节点 \(j+1\) 之间是否有边<br> $$vertices = [1, 2, 3, 4, 5] \\edges =  \left[ \begin{matrix} 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\ 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\ 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\ 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \\ \end{matrix} \right]$$</p></li><li><p><strong>邻接表</strong>：使用数组 \(vertices\) 存储顶点，二维数组 \(edges\) 存储边；\(edges[i]\) 存储着与节点 \(i+1\) 存在边关系的所有节点索引集合。<br> $$vertices = [1, 2, 3, 4, 5] \\edges =  \left[ \begin{matrix} [1 &amp; 2 &amp; 3 &amp; 4 ] \\ [0 &amp; 3] \\ [0 &amp; 4] \\ [0 &amp; 1 &amp; 4] \\ [0 &amp; 2 &amp; 3] \\ \end{matrix} \right]$$</p><blockquote><p><strong>邻接矩阵 VS 邻接表：</strong><br>   邻接矩阵的大小是\(vertice^2\)，因此，边数量明显少于顶点数量时，使用邻接矩阵存储图会造成较大的内存浪费。<br>   所以，<strong>邻接表</strong> 适合存储 稀疏图（顶点多，边少）；<strong>邻接矩阵</strong> 适合存储 稠密图（顶点少，边多）</p></blockquote></li></ol></li><li><h3 id="散列表-Hash-List"><a href="#散列表-Hash-List" class="headerlink" title="散列表 Hash List"></a>散列表 Hash List</h3><p>  通过 Hash 函数 将指定的 Key 映射对应 Value， 实现高效的元素查找。</p>  <blockquote><p>实际的 Hash 函数需保证低碰撞率、 健壮性等，以适用于各类数据和场景。</p></blockquote>  <figure class="highlight typescript"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hash</span>(<span class="hljs-params">id: <span class="hljs-built_in">number</span></span>) </span>&#123;<br><span class="hljs-keyword">return</span> (id - <span class="hljs-number">1</span>) % <span class="hljs-number">10000</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> names = &#123;&#125;;<br>names[hash(<span class="hljs-number">10001</span>)] = <span class="hljs-string">&quot;小力&quot;</span>;<br>names[hash(<span class="hljs-number">10002</span>)] = <span class="hljs-string">&quot;小特&quot;</span>;<br>names[hash(<span class="hljs-number">10003</span>)] = <span class="hljs-string">&quot;小扣&quot;</span>;<br><br><span class="hljs-comment">//or</span><br><br><span class="hljs-keyword">let</span> nampesMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">number</span>,<span class="hljs-built_in">string</span>&gt;();<br>nampesMap.set(hash(<span class="hljs-number">10001</span>), <span class="hljs-string">&quot;小力&quot;</span>);<br>nampesMap.set(hash(<span class="hljs-number">10002</span>), <span class="hljs-string">&quot;小特&quot;</span>);<br>nampesMap.set(hash(<span class="hljs-number">10003</span>), <span class="hljs-string">&quot;小扣&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><h3 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆 Heap"></a>堆 Heap</h3><p>  基于「完全二叉树」的数据结构，可使用数组实现。</p><blockquote><p><strong>完全二叉树定义</strong>： 设二叉树深度为 \(k\) ，若二叉树除第 \(k\) 层外的其它各层（第 \(1\) 至 \(k-1\) 层）的节点达到最大个数，且处于第 \(k\) 层的节点都连续集中在最左边，则称此二叉树为完全二叉树。</p></blockquote>  <img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202103/illustration-of-algorithm-1/heap.png" class="center" width="500"><blockquote><p>这里同样先简单看一下，详细的 数据结构特点、应用场景、算法后续再继续深入的学习实践与了解</p></blockquote></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
          <category> 技术类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读笔记 </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读记《图解HTTP》 认证、追加协议和攻击手段</title>
      <link href="202103/read-book-diagram-http-4/"/>
      <url>202103/read-book-diagram-http-4/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202103/read-book-diagram-http-4/cover.png" class="" width="0" height="0"><h1 id="用户身份认证"><a href="#用户身份认证" class="headerlink" title="用户身份认证"></a>用户身份认证</h1><p>确认通过客户端访问服务器的用户身份</p><ul><li><h2 id="BASIC-认证"><a href="#BASIC-认证" class="headerlink" title="BASIC 认证"></a>BASIC 认证</h2><blockquote><p>由 HTTP/1.0 便定义的认证方式</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202103/read-book-diagram-http-4/http_basic_auth.png" class=""></blockquote><p>当访问资源需要认证时服务器端返回 401 状态码告知客户端需要认证后，</p><ol><li> 客户端弹出输入框输入用户名与密码；</li><li> 将用户名密码以 <code>&#123;username&#125;:&#123;password&#125;</code> 格式 Base64 编码后发送</li><li> 认证成功后返回状态码 200</li></ol><blockquote><p>命令行 curl 或直接获取时可以下方链接示例请求，跳过另外输入用户名与密码过程<br><code>http://&#123;username&#125;:&#123;password&#125;@example.com/</code></p></blockquote><p>缺点：由于用户名密码未经过加密传输，而是直接通过 Base64 编码，当网络被劫持获取 HTTP 报文后，可直接通过 Base64 解码获取用户名与密码。</p></li><li><h2 id="DIGEST-认证"><a href="#DIGEST-认证" class="headerlink" title="DIGEST 认证"></a>DIGEST 认证</h2><p>HTTP/1.1 定义的认证方式，弥补 BASIC 认证 存在的弱点。</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202103/read-book-diagram-http-4/http_digest_auth.png" class=""><ol><li>当访问资源需要认证时服务器端返回 401 状态码告知客户端需要认证后，并携带认证所需的质询码<code>nonce</code>。<blockquote><p>WWW-Authenticate 内必须含 <code>realm</code>和<code>nonce</code>两个字段</p></blockquote></li><li>通过客户端发送 Authenticate 首部字段，字段内包含 <code>username</code>、<code>realm</code>、<code>nonce</code>、<code>uri</code>和<code>response</code>字段信息。<ul><li>uri 即 Request-URI 值，考虑经过代理转发后值会被修改，因此会事先复制一份副本保存在 uri 内</li><li>response 存放经过 MD5 运算后的密码字符串</li></ul></li></ol><p>缺点：虽然提供了高于 BASIC 认证的安全等级，与防止密码被窃听的保护机制，但不存在防止用户伪装的保护机制。</p></li><li><h2 id="SSL-客户端认证"><a href="#SSL-客户端认证" class="headerlink" title="SSL 客户端认证"></a>SSL 客户端认证</h2><p>通过安装服务器分发的证书并安装后通过 HTTPS 方式将证书信息以 Client Certificate 报文方式发送给服务器认证。</p><ol><li> 接收到需要认证资源的请求，服务器会发送 Certificate Request 报文，要求客户端提供客户端证书。</li><li> 用户选择将发送的客户端证书后，客户端会把客户端证书信息以 Client Certificate 报文方式发送给服务器。</li><li> 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始 HTTPS 加密通信。</li></ol><blockquote><p>SSL 客户端认证一般采用 表单认证 + SSL 客户端认证 双因素认证使用</p></blockquote><p>缺点：证书需要费用。</p></li><li><h2 id="表单认证"><a href="#表单认证" class="headerlink" title="表单认证"></a>表单认证</h2><p>非 HTTP 协义定义的认证方式；客户端向服务器发送 WEB 表单信息 认证。</p></li></ul><h1 id="基于-HTTP-的功能追加协议"><a href="#基于-HTTP-的功能追加协议" class="headerlink" title="基于 HTTP 的功能追加协议"></a>基于 HTTP 的功能追加协议</h1><ul><li><h2 id="SPDY：消除-HTTP-瓶颈"><a href="#SPDY：消除-HTTP-瓶颈" class="headerlink" title="SPDY：消除 HTTP 瓶颈"></a>SPDY：消除 HTTP 瓶颈</h2><p>由 Google 开发，用于解决 HTTP 的性能瓶颈。</p><blockquote><p>如 Facebook 和 Twitter 等 SNS 网站上，可以实时观察海量用户公开发布的内容，当几百、几千万的用户发布内容时，在很短的时间内会发生大量的内容更新。<br>以下 HTTP 协议标准成为了瓶颈</p></blockquote><ul><li>一条连接上只可发送一个请求</li><li>请求只能从客户端开始。客户端不可接收除响应以外的指令</li><li>请求/响应首部未经压缩就发送</li><li>发送冗长的首部，且每次互相发送相同的首部造成的浪费较多</li><li>可任意选择数据压缩格式，非强制性</li></ul><h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><p>AJAX(Asynchronous JavaScript and XML) 利用 JS 和 DOM 操作，完成对局部 Web 页面 替换加载的异步通信手段。由于只更新局部页面，响应的数据量传输就可以大大减少。</p><p>AJAX 核心技术是通过 XMLHTTPRequest 的 API，通过 JavaScript 完成与服务器的 HTTP 通信。</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202103/read-book-diagram-http-4/http_ajax.png" class="" width="600"><h3 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h3><p>通过服务器接收到请求会在处理完毕后立即返回响应，但为了实现推送功能，会先将响应挂起，当服务器有了内容更新后再返回响应。为了保留响应，一次连接的持续时间也变长了，使的消耗更多的资源。</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202103/read-book-diagram-http-4/http_comet.png" class="" width="600"><h3 id="设计与功能"><a href="#设计与功能" class="headerlink" title="设计与功能"></a>设计与功能</h3><p>SPDY 没有完全改写 HTTP 协议，SPDY 以会话层的形式加入，控制对数据的流动，但还是采用 HTTP 建立通信连接。</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202103/read-book-diagram-http-4/spdy.png" class="" width="200"><p>SPDY 赋予了 HTTP 协议以下功能</p><ul><li><p><strong>多路复用流</strong><br>通过一次的 TCP 连接打开页面后，可以通过 AJAX 无限制的处理多次 HTTP 请求。</p></li><li><p><strong>赋予请求优先级</strong><br>可以通过 JS 按顺序 AJAX 请求，解决因宽带低导致响应变的问题</p></li><li><p><strong>压缩 HTTP 首部</strong><br>压缩了 HTTP 首部，减少了通信消耗</p></li><li><p><strong>推送功能</strong><br>服务器可直接发送数据，而不必等待客户端的请求</p></li><li><p><strong>服务器提示功能</strong><br>由于在客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求。</p></li></ul></li><li><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>建立在 HTTP 协议 基础上，因此连接的发起方仍是客户端。一旦确立了 WebSocket 的通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。</p><p><strong>主要特点</strong></p><ul><li>推送功能</li><li>减少通信量</li></ul><h2 id="WebSocket-通信步骤"><a href="#WebSocket-通信步骤" class="headerlink" title="WebSocket 通信步骤"></a>WebSocket 通信步骤</h2><ul><li><h3 id="握手请求"><a href="#握手请求" class="headerlink" title="握手请求"></a>握手请求</h3>应用 HTTP 首部字段 <code>Upgrade</code> 更新为 websocket 协议<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">GET &#x2F;chat HTTP&#x2F;1.1<br>Host: socket.example.com<br>Upgrade: websocket<br>Connection: Upgrade<br>Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ&#x3D;&#x3D;<br>Origin:http:&#x2F;&#x2F;example.com<br>Sec-WebSocket-Protocol:chat,superchat<br>Sec-WebSocket-Version:13<br></code></pre></td></tr></table></figure><code>Sec-WebSocket-Key</code> 记录着握手的必需主键<br><code>Sec-WebSocket-Protocol</code> 定义连接的名称 “,”分隔</li><li><h3 id="握手响应"><a href="#握手响应" class="headerlink" title="握手响应"></a>握手响应</h3>返回状态码 101 Switching Protocols 的响应。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">HTTP&#x2F;1.1 101 Switching Protocols<br>Upgrade: websocket<br>Connection: Upgrade<br>Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo&#x3D;<br>Sec-WebSocket-Protocol: chat<br></code></pre></td></tr></table></figure><code>Sec-WebSocket-Accept</code> 的字段值是由握手请求中的 <code>Sec-WebSocket-Key</code> 的字段值生成的。</li></ul><p>成功确认连接后，通信时不再使用 HTTP 的数据帧，而采用 WebSocket 独立数据帧</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202103/read-book-diagram-http-4/websocket.png" class="" width="600"></li><li><h2 id="期待-HTTP-2-0"><a href="#期待-HTTP-2-0" class="headerlink" title="期待 HTTP/2.0"></a>期待 HTTP/2.0</h2><p>HTTP Speed + Mobility 由微软公司起草，建立在 Google 公司提出的 SPDY 与 WebSocket 的基础上。<br>Netword-Friendly HTTP Upgrade 主要是在移动端通信时改善 HTTP 性能</p><h3 id="HTTP-2-0-7项技术与讨论"><a href="#HTTP-2-0-7项技术与讨论" class="headerlink" title="HTTP/2.0 7项技术与讨论"></a>HTTP/2.0 7项技术与讨论</h3><table><thead><tr><th align="left">技术</th><th align="left">采用协议</th></tr></thead><tbody><tr><td align="left">压缩</td><td align="left">SPDY、Friendly</td></tr><tr><td align="left">TLS 义务化</td><td align="left">SPDY</td></tr><tr><td align="left">协商</td><td align="left">Speed+Mobility</td></tr><tr><td align="left">客户端拉取/服务端推送</td><td align="left">Speed+Mobility、Friendly</td></tr><tr><td align="left">流量控制</td><td align="left">SPDY</td></tr><tr><td align="left">WebSocket</td><td align="left">Speed+Mobility</td></tr></tbody></table></li></ul><h1 id="针对-Web-的攻击技术"><a href="#针对-Web-的攻击技术" class="headerlink" title="针对 Web 的攻击技术"></a>针对 Web 的攻击技术</h1><blockquote><p>HTTP 的设计初衷本就是更好的分享知识，是一种通用单纯协议机制；因此不具备必要的安全性功能。</p></blockquote><ul><li><h2 id="因输出值转义不完全引发"><a href="#因输出值转义不完全引发" class="headerlink" title="因输出值转义不完全引发"></a>因输出值转义不完全引发</h2><p>  通过URL查询字段，表单提交，HTTP首部字段提交含有攻击命令的代码，Web应用未对用户提交的数据进行转义处理，相应的攻击语句则会入侵了数据库或系统。<br>  客户端 JS 对用户提交数据的进行转义处理对Web应用的攻击起不到保护作用。客户端校验主要是起到UI体验的作用。</p><ul><li><p><strong>XSS 跨站脚本攻击</strong><br>  利用未对用户输入进行转义处理的表单，提交非法 HTML 标签或 JavaScript 脚本。网站动态生成并执行了未转义的攻击代码，通过攻击代码获取用户cookie等会话，将信息提交至攻击者网站等。</p></li><li><p><strong>SQL注入攻击</strong><br>  通过攻击者输入的查询文本，Web应用未转义并直接拼接至SQL语句中，返回攻击者想要窃取的信息。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 正常的Sql语句</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> bookTbl <span class="hljs-keyword">WHERE</span> author <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;上野宣&#x27;</span> <span class="hljs-keyword">and</span> flag <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-comment">-- 攻击者传入的语句: `--`之后全是注释了，缺少了flag=1的条件</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> bookTbl <span class="hljs-keyword">WHERE</span> author <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;上野宣&#x27;</span><span class="hljs-comment">--&#x27; and flag = 1</span><br></code></pre></td></tr></table></figure></li><li><p><strong>OS命令注入攻击</strong><br>  通过Web应用，执行非法的操作系统命令达到攻击的目的。只要在能调用Shell函数的地方就有存在被攻击的风险。</p></li><li><p><strong>HTTP首部注入攻击</strong><br>  攻击者通过在响应截断，在响应返回首部字段内插入换行，添加任意响应首部，如重定向至攻击者网站透导用户填入个人信息。</p></li><li><p><strong>目录遍历攻击</strong><br>  对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击。这种攻击有时也称为路径遍历（Path Traversal）攻击。</p></li><li><p><strong>远程文件包含漏洞</strong><br>  当部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的URL充当依赖文件，让脚本读取之后，就可运行任意脚本的一种攻击。（这主要是PHP存在的安全漏洞，对PHP的include或require来说，这是一种可通过设定，指定外部服务器的URL作为文件名的功能。）</p></li></ul></li><li><h2 id="设置或设计的缺陷引发"><a href="#设置或设计的缺陷引发" class="headerlink" title="设置或设计的缺陷引发"></a>设置或设计的缺陷引发</h2><ul><li><p><strong>强制游览</strong><br>  主要是指未对不应公开的 备份文件 或 配置文件 设置拒绝访问，导致配置信息泄漏等安全问题。</p></li><li><p><strong>不正确的错误消息处理</strong><br>  指 Web应用 将 应用错误消息、数据库等系统错误消息 未处理直接抛出，使得攻击者获得下一步的攻击情况，实施更致命的攻击。</p></li><li><p><strong>开放重定向</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">http:&#x2F;&#x2F;example.com&#x2F;?rediect&#x3D;http:&#x2F;&#x2F;hacker.site<br></code></pre></td></tr></table></figure><p>由Web应用支持开放自定义重定向功能，用户通过URL链接以为是访问 <code>example.com</code> 的网址，实际被诱导跳转至攻击者的 <code>http://hacker.site</code> 网站</p></li></ul></li><li><h2 id="因会话管理疏忽引发"><a href="#因会话管理疏忽引发" class="headerlink" title="因会话管理疏忽引发"></a>因会话管理疏忽引发</h2><ul><li><p><strong>会话劫持</strong><br>攻击者通过非正规生成方法推测会话Cookie/ID、窃听或XSS攻击和会话固定攻击获取会话Cookie/ID。<br>使用窃取的会话Cookie/ID对应的用户身份访问网站；实施非法行为。</p></li><li><p><strong>会话固定攻击</strong></p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202103/read-book-diagram-http-4/attack_session.jpg" class=""><p>攻击者可私自创建会员ID构成陷阱，诱导用户使用该会话ID进行认证后激活攻击者创建的会话ID，攻击者就可以通过该会话ID进行访问</p><blockquote><p>Session Adoption 主指 PHP 或 ASP.NET 能够接收处理未知会话ID的功能。</p></blockquote></li><li><p><strong>跨站点请求伪造（CSRF)</strong></p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202103/read-book-diagram-http-4/attack_csrf.jpg" class=""><p>攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新。<br>如：攻击者通过 因未完成转义处理 为用户设下脚本陷阱，当用户触发陷阱时，并且用户已登陆认证时，将触发用户不知情的攻击行为。</p></li></ul></li></ul><ul><li><h2 id="其它安全漏洞"><a href="#其它安全漏洞" class="headerlink" title="其它安全漏洞"></a>其它安全漏洞</h2><ul><li><p><strong>密码破解</strong><br>这里就不多说了，通过对 Web应用 进行暴力破解，或通过社会工程学收集到的用户信息生成可能的密码字典尝试出真实密码。<br>所以 Web应用 需要对认证窗口增验证码及最大尝试次数限制，防止此攻击</p></li><li><p><strong>点击劫持</strong><br>通过透明的按钮或链接做成陷阱，误导用户不知情下点击进入陷阱。</p></li><li><p><strong>DoS攻击</strong><br>最无解的一种攻击方式，通过海量的请求导致服务器呈现停止状态，或通过攻击安全漏洞使服务停止。攻击通过扫描嗅探网络中有安全漏洞的服务器（肉鸡），利用多台肉鸡攻击目标服务器。<br>常见的防御方式是动态CDN和增加服务器带宽。</p></li><li><p><strong>后门程序</strong><br>开发设置的隐藏入口，可不按正常方式使用受限功能。</p><ul><li>开发阶段作为 Debug 调用的后门程序</li><li>开发者为了自身利益植入后门程序</li><li>攻击者通过某种方法设置后门程序</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
          <category> 技术类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读笔记 </tag>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读记《图解HTTP》Web服务器与HTTPS</title>
      <link href="202103/read-book-diagram-http-3/"/>
      <url>202103/read-book-diagram-http-3/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202103/read-book-diagram-http-3/cover.png" class="" width="0" height="0"><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>HTTP 的缺点：</p><ul><li>通信使用明文（不加密），内容可能会被窃听</li><li>不验证通信方的身份，可能遭遇伪装</li><li>无法证明报文的完整性，所以有可能被篡改</li></ul><p>根据上面的缺点，加以保护，诞生了现在的 HTTPS</p><p>HTTP + 加密 + 认证 + 完整性保护 = HTTPS</p><h2 id="HTTPS-是身披-SSL-外壳的-HTTP"><a href="#HTTPS-是身披-SSL-外壳的-HTTP" class="headerlink" title="HTTPS 是身披 SSL 外壳的 HTTP"></a>HTTPS 是身披 SSL 外壳的 HTTP</h2><p>HTTPS 并非是应用层的一种新协议，HTTP 通信接口部分用 SSL 和 TLS 协议代替</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202103/read-book-diagram-http-3/https.png" class="" width="600"><h2 id="HTTPS-加密机制"><a href="#HTTPS-加密机制" class="headerlink" title="HTTPS 加密机制"></a>HTTPS 加密机制</h2><ul><li><p><strong>共享密钥加密</strong><br>加密与解密用同一密钥的方式称为共享密钥加密，亦称对称密钥加密。</p></li><li><p><strong>公开密钥加密</strong><br>发送请求时发送密文一方通过证书公开密钥加密，收到加密消息后再利用私有密钥解密。这样就不需要发送用于解密的私有密钥。公开密钥+密文恢复信息原文是异常困难的。</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202103/read-book-diagram-http-3/https_ssl.jpg" class="" width="600"></li><li><p><strong>HTTPS 采用混合加密机制</strong><br>HTTPS 采用上面两种并用的加密机制。公开密钥处理速度慢；所有先通过公开密钥机制安全的将共享密钥交予对方后，再采用共享密钥方式进行通信</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202103/read-book-diagram-http-3/https_crypto.png" class="" width="600"></li></ul><h2 id="证明密钥正确性"><a href="#证明密钥正确性" class="headerlink" title="证明密钥正确性"></a>证明密钥正确性</h2><p>在建立公开密钥加密方式通信时，服务器无法保证公开密钥是否被攻击者替换，为了解决此问题，就需要使用数字证书认证机构(CA, Certificate Authority)和相关机关颁发的公开密钥证书。</p><ol><li>申请公钥证书<br><strong>数字证书认证机构</strong>是客户端与服务端都可信赖的第三方机构。由服务器运营人员向机构提出公开密钥的申请，机构验明申请者身份后，对公开密钥做数字签名，并将公开密钥与公钥证书绑定。</li><li>向请求客户端发送公钥证书<br>服务器将机构颁发的公钥证书发给客户端以进行公开密钥加密方法通信。</li><li>客户端确认公钥证书后通信<br>客户端接收到证书后确认：<ul><li>收到的公钥证书为真实有效的数字证书认证机构颁发的。</li><li>服务器的公开密钥是值得依赖的。</li></ul></li></ol><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202103/read-book-diagram-http-3/https_ca.png" class="" width="600"><h2 id="HTTPS-通信过程"><a href="#HTTPS-通信过程" class="headerlink" title="HTTPS 通信过程"></a>HTTPS 通信过程</h2><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202103/read-book-diagram-http-3/https_flow.png" class="" width="600"><blockquote><p>应用层数据数据时会附加 MAC(Message Authentication Code) 报文摘要。能够查知报文是否遭到篡改。</p></blockquote><h3 id="SSL-和-TLS"><a href="#SSL-和-TLS" class="headerlink" title="SSL 和 TLS"></a>SSL 和 TLS</h3><p>HTTPS 使用 SSL(Secure Socket Layer) 和 TLS(Transport Layer Security) 两个协议</p><ul><li>SSL1.0 与 SSL2.0 都先后在设计之初和后面就发现了问题，1.0 并没有实际投入使用，许多浏览器直接废除了 2.0 版本。</li><li>IETF 以 SSL3.0 为基准，后制定了 TLS1.0、TLS1.1 和 TLS1.2。有时也统一称为 SSL。主要使用的是版本是 SSL3.和 TLS1.0。</li></ul><blockquote><p>HTTPS 比 HTTP 速度慢 2~100倍，加密与解密运算对CPU及内存资源的消耗大</p></blockquote><h1 id="Web-服务器"><a href="#Web-服务器" class="headerlink" title="Web 服务器"></a>Web 服务器</h1><p>HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点。</p><h2 id="通信数据转发程序"><a href="#通信数据转发程序" class="headerlink" title="通信数据转发程序"></a>通信数据转发程序</h2><ul><li><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>代理是一种转发功能的应用程序，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202103/read-book-diagram-http-3/http_proxy.jpg" class=""><p>每经过代理服务器转发请求或响应时，都会追加写入 Via 首部信息</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202103/read-book-diagram-http-3/http_multiple_proxy.jpg" class=""><blockquote><p>使用代理服务器的理由：</p><ul><li>利用缓存技术减少网络带宽的流量</li><li>针对特定网站的访问控制</li><li>获取访问日志</li></ul></blockquote><ul><li><h3 id="缓存代理-Caching-Proxy"><a href="#缓存代理-Caching-Proxy" class="headerlink" title="缓存代理 Caching Proxy"></a>缓存代理 Caching Proxy</h3><p>代理转发响应时将资源副本缓存在代理服务器上，当再次接收到相同资源请求时，则不再请求源服务器，直接返回缓存在代理服务器的副本</p><blockquote><p>缓存的有效期限会根据客户端的要求、缓存的有效期等，向源服务器确认资源有效性，若失效则会向源服务器获取“新”资源</p></blockquote></li><li><h3 id="透明代理-Transparent-Proxy"><a href="#透明代理-Transparent-Proxy" class="headerlink" title="透明代理 Transparent Proxy"></a>透明代理 Transparent Proxy</h3><p>不对报文做任何的加工代理方式，</p><blockquote><p>反之对报文内容加工的代理方式称<code>为非透明代理</code></p></blockquote></li></ul></li><li><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202103/read-book-diagram-http-3/http_gate_way.jpg" class=""><p>工作机制与代理非常相似，但网关能使通信线路上的服务器提供非 HTTP 协议服务，且具有更高的通信安全性，客户端与网关间的通信线路可加密确保连接安全。</p></li><li><h2 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h2><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202103/read-book-diagram-http-3/http_tunnel.jpg" class=""><p>可按要求建立起一条与其他服务器的通信线路，届时使用 SSL 等加密手段进行通信。目的是确保客户端与服务器的通信安全。隧道本身不会解析请求</p></li><li><h2 id="编码传输速率"><a href="#编码传输速率" class="headerlink" title="编码传输速率"></a>编码传输速率</h2><ul><li><p><strong>报文主体与实体主体差异</strong></p><ul><li><p><strong>报文(message)</strong><br>是 HTTP 通信中的基本单位，由 8 位组字节流组成、 通过 HTTP 通信传输</p></li><li><p><strong>实体(entity)</strong><br>为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成</p></li></ul><p>通常，报文主体等于实体主体。只有当传输中进行编码时，实体主体的内容发生变化，导致它和报文主体产生差展示</p></li><li><p><strong>常用压缩传输的内容编码</strong></p><ul><li>gzip (GUN zip)</li><li>compress (UNIX 系统的标准压缩)</li><li>deflate (zlib)</li><li>identity (不进行编码)</li></ul></li><li><p><strong>分割发送的分块传输编码（Chunked Transfer Coding）</strong><br>在 HTTP 通信时，请求的编码实体资源尚未全部传输完成前，浏览器无法显示请求的页面。在传输大容量数据时，通过将数据分割成多块，让浏览器逐步显示页面。<br>将实体主体分块，将每一块用<code>十六进制</code>标记块的大小，最后一块使用<code>0(CR+LF)</code>标记</p></li></ul></li><li><h2 id="发送多种数据的多部分对象集合"><a href="#发送多种数据的多部分对象集合" class="headerlink" title="发送多种数据的多部分对象集合"></a>发送多种数据的多部分对象集合</h2><p>HTTP 协议中采用了与 MIME（Multipurpose Internet Mail Extensions) 同样的多部分对象集合，发送一份报文主体内可含有多类型实体。</p><ul><li><h3 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a>multipart/form-data</h3><p>Web 表单文件上传时使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">Content-Type: multipart&#x2F;form-data;boundary&#x3D;AaB03x<br><br>--AaB03x<br>Content-Dispostion: form-data; name&#x3D;&quot;field1&quot;<br><br>JoeBlow<br>--AaB03x<br>Content-Dispostion: form-data; name&#x3D;&quot;pics&quot;; filename&#x3D;&quot;file1.txt&quot;<br>Content-Type: text&#x2F;plain<br><br>...(file1.txt的数据)...<br>--AaB03x--<br></code></pre></td></tr></table></figure></li><li><h3 id="multipart-byteranges"><a href="#multipart-byteranges" class="headerlink" title="multipart/byteranges"></a>multipart/byteranges</h3><p>状态码 206（部分内容）响应报文包含了多个范围的内容时使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">HTTP&#x2F;1.1 206 Partial Content<br>Date: Fri,13 Jul 2012 02:45:26 GMT<br>Last-Modified: Fri,13 Jul 2012 02:45:26 GMT<br>Content-Type: multipart&#x2F;byteranges; boundary&#x3D;THIS_STRING_SEPARATES<br><br>--THIS_STRING_SEPARATES<br>Content-Type: application&#x2F;pdf<br>Content-Range: bytes 500-999&#x2F;8000<br><br>--THIS_STRING_SEPARATES<br>Content-Type: application&#x2F;pdf<br>Content-Range: bytes 7000-7999&#x2F;8000<br><br>--THIS_STRING_SEPARATES--<br></code></pre></td></tr></table></figure><p>使用 <code>boundary</code> 字符串划分多部分对象集合指明的各类实体。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plain">Content-Type: multipart&#x2F;form-data; boundary&#x3D;[多部分名称字符]<br><br>--[多部分名称字符]<br>实体首部字段1<br><br>实体数据1<br><br>--[多部分名称字符]<br>实体首部字段2<br><br>实体数据2<br><br>...<br><br>--[多部分名称字符]--<br></code></pre></td></tr></table></figure></li></ul></li><li><h2 id="获取部分内容范围请求"><a href="#获取部分内容范围请求" class="headerlink" title="获取部分内容范围请求"></a>获取部分内容范围请求</h2><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202103/read-book-diagram-http-3/http_range_byte.jpg" class="" width="500"><ul><li><h3 id="byte-指定形式"><a href="#byte-指定形式" class="headerlink" title="byte 指定形式"></a>byte 指定形式</h3><ul><li>范围<br><code>Range: bytes=5001-10000</code></li><li>由指定字节之后<br><code>Range: bytes=5001-</code></li><li>由指定字节之前<br><code>Range: bytes=-5001</code></li><li>多重范围<br><code>Range: bytes=-3000,5000-7000</code></li></ul></li></ul></li><li><h2 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h2><p>内容协商机制指客户端和服务端就响应资源交涉，为客户端提供最合适的资源，判断基准以语言、字符集、编码方式。</p><ul><li>服务端驱动协商<br>以请求首部字段参考，在服务端自动处理。但对用户来说，以浏览器发送的信息作为判定依据，不一定能筛出最优内容</li><li>客户端驱动协商<br>用户从浏览器显示的可选项列表手动选择，亦可利用 Javascript 脚本在页面上自动选择，如：按 OS 类型或浏览器类型切换 PC 版页面或手机版页面</li><li>透明协商<br>服务商与客户端各自进行内容协商的方法</li></ul></li></ul><h1 id="继续阅读"><a href="#继续阅读" class="headerlink" title="继续阅读"></a>继续阅读</h1><ul><li><a href="/202103/read-book-diagram-http-4/" title="读记《图解HTTP》 认证、追加协议和攻击手段">读记《图解HTTP》 认证、追加协议和攻击手段</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
          <category> 技术类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读笔记 </tag>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读记《图解HTTP》HTTP报文与状态码</title>
      <link href="202102/read-book-diagram-http-2/"/>
      <url>202102/read-book-diagram-http-2/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202102/read-book-diagram-http-2/cover.png" class="" width="0" height="0"><h1 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h1><ul><li><h2 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h2><p>下图为请求报文及响应报文结构</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202102/read-book-diagram-http-2/http_message_struc.jpg" class=""><table><thead><tr><th align="left">组成</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">请求行</td><td align="left"><code>[请求方法] [URI] [HTTP版本]</code> 格式，用于请求时</td></tr><tr><td align="left">状态行</td><td align="left"><code>[HTTP版本] [HTTP状态码] [原因短语]</code> 格式，告知响应的状态</td></tr><tr><td align="left">首部字段</td><td align="left">每个字段以 <code>[字段名]:[字段值]</code> 为一行格式写入，一般首部分为：通用首部、请求首部、响应首部和实体首部</td></tr><tr><td align="left">其他</td><td align="left">可能包含 HTTP 的 RFC 里未定义的首部，如 Cookie 等</td></tr></tbody></table></li><li><h2 id="HTTP-首部字段"><a href="#HTTP-首部字段" class="headerlink" title="HTTP 首部字段"></a>HTTP 首部字段</h2><p>HTTP 首部字段是 HTTP 报文的构成要素之一；无论在请求或响应中都会应用，起到传递额外重要信息的作用。</p><blockquote><p>首部字段中每个字段以 <code>[字段名]:[字段值]</code> 构成</p></blockquote><ul><li><h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><p>请求报文与响应报文都会使用的首部字段</p><table><thead><tr><th align="left">首部字段名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Date</td><td align="left">创建报文时间</td></tr><tr><td align="left">Cache-Control</td><td align="left">缓存的控制</td></tr><tr><td align="left">Connection</td><td align="left">逐跳首部、连接的管理</td></tr><tr><td align="left">Keep-Alive</td><td align="left">设置连接的超时时长和最大请求</td></tr><tr><td align="left">Pragma</td><td align="left">报文指令</td></tr><tr><td align="left">Trailer</td><td align="left">报文末端的首部一览</td></tr><tr><td align="left">Transfer-Encoding</td><td align="left">报文主体的传输编码方式</td></tr><tr><td align="left">Upgrade</td><td align="left">升级为其他协议</td></tr><tr><td align="left">Via</td><td align="left">代理服务器相关信息</td></tr><tr><td align="left">Warning</td><td align="left">错误通知</td></tr></tbody></table><ul><li><h4 id="连接管理-Connection"><a href="#连接管理-Connection" class="headerlink" title="连接管理 Connection"></a>连接管理 Connection</h4><ul><li><strong>控制不再转发给代理的首部字段</strong><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202102/read-book-diagram-http-2/http_connection.png" class=""></li><li><strong>管理持久连接</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">Connection: close 关闭连接<br>Connection: Keep-Alive 持续连接<br></code></pre></td></tr></table></figure></li></ul></li><li><h4 id="缓存-Cache"><a href="#缓存-Cache" class="headerlink" title="缓存 Cache"></a>缓存 Cache</h4><blockquote><p>Pragma 为 HTTP/1.1 之前版本的历史遗留，仅作为与 HTTP/1.0 向后兼容而定义</p></blockquote><p>通过首部字段 Cache-Control 控制缓存的工作机制<br>缓存指令按请求和响应分类如下</p><ul><li><p><strong>缓存请求指令</strong></p><table><thead><tr><th align="left">指令</th><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">no-chche</td><td align="left">无</td><td align="left">强制向源服务器再次验证</td></tr><tr><td align="left">no-store</td><td align="left">无</td><td align="left">不缓存请求或响应的任务内容</td></tr><tr><td align="left">max-age=[秒]</td><td align="left">必填</td><td align="left">响应的最大 Age 值</td></tr><tr><td align="left">max-stale(=[秒])</td><td align="left">可空</td><td align="left">接收已过期的响应，即使过期的资源也接收</td></tr><tr><td align="left">max-fresh=[秒]</td><td align="left">必填</td><td align="left">期望在指定时间内的响应仍有效</td></tr><tr><td align="left">no-transform</td><td align="left">无</td><td align="left">代理不可更改媒体类型</td></tr><tr><td align="left">only-if-cached</td><td align="left">无</td><td align="left">从缓存获取资源</td></tr><tr><td align="left">cache-extension</td><td align="left">-</td><td align="left">新指令标记</td></tr></tbody></table></li><li><p><strong>only-if-cached</strong><br>表示客户端仅在缓存服务器获取目标资源，请求缓存服务器的本地缓存无响应，则返回 504 Gateway Timeout</p></li><li><p><strong>缓存响应指令</strong></p><table><thead><tr><th align="left">指令</th><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">public</td><td align="left">无</td><td align="left">可向任意方提供响应缓存</td></tr><tr><td align="left">private</td><td align="left">无</td><td align="left">仅向特定用户返回响应</td></tr><tr><td align="left">no-chche</td><td align="left">无</td><td align="left">强制向源服务器再次验证</td></tr><tr><td align="left">no-store</td><td align="left">无</td><td align="left">不缓存请求或响应的任务内容</td></tr><tr><td align="left">no-transform</td><td align="left">无</td><td align="left">代理不可更改媒体类型</td></tr><tr><td align="left">must-revalidate</td><td align="left">无</td><td align="left">可缓存但必须再向源服务器进行确认</td></tr><tr><td align="left">proxy-revalidate</td><td align="left">无</td><td align="left">要求中间缓存服务器对缓存的响应有效性确认</td></tr><tr><td align="left">max-age=[秒]</td><td align="left">必填</td><td align="left">响应的最大 Age 值</td></tr><tr><td align="left">s-maxage=[秒]</td><td align="left">必填</td><td align="left">公共缓存服务器响应的最大 Age 值</td></tr><tr><td align="left">cache-extension</td><td align="left">-</td><td align="left">新指令标记</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">Cache-Control: private,max-age&#x3D;0,no-cache<br># 缓存多个指令通过 “,&quot; 分隔<br></code></pre></td></tr></table></figure></li><li><p><strong>易误解的两个指令：no-cache 指令 或 no-store 指令</strong></p><ul><li>no-cache 指令的目地是防止从缓存中返回过期的资源</li><li>no-store 指令的目地才是真正的不进行缓存</li></ul></li><li><p><strong>s-maxage 指令 和 max-age 指令</strong><br><code>s-maxage</code>指令与<code>max-age</code>指令相同，不同在于 <code>s-maxage</code> 只适用于供多用户使用的公共缓存服务器（指代理服务器）<br>如果缓存资源缓存时间数值 &lt; 指令设定时间数值，客户端接受缓存的资源。</p><blockquote><p>s-maxmage 指令后，则直接忽略对 Expires 首部字段 和 max-age 指令</p></blockquote></li></ul></li></ul></li><li><h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><p>请求报文会使用的首部字段</p><table><thead><tr><th align="left">首部字段名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Host</td><td align="left">请求资源所在服务器</td></tr><tr><td align="left">Accept</td><td align="left">用户可代理的的媒体类型</td></tr><tr><td align="left">Accept-Charset</td><td align="left">可接收的字符集</td></tr><tr><td align="left">Accept-Encoding</td><td align="left">可接受的内容编码</td></tr><tr><td align="left">Accept-Language</td><td align="left">可接受的自然语言</td></tr><tr><td align="left">Authorization</td><td align="left">Web 认证信息</td></tr><tr><td align="left">Form</td><td align="left">用户的电子邮箱地址</td></tr><tr><td align="left">Expect</td><td align="left">期待服务器的特定行为</td></tr><tr><td align="left">If-Match</td><td align="left">比较实体标记（ETag）</td></tr><tr><td align="left">If-Modified-Since</td><td align="left">比较资源的更新时间</td></tr><tr><td align="left">If-None-Match</td><td align="left">比较实体标记（与 If-Match 相反）</td></tr><tr><td align="left">If-Range</td><td align="left">资源未更新时发送实体字节的范围请求</td></tr><tr><td align="left">If-Unmodified-Since</td><td align="left">比较资源的更新时间（与 If-Modified-Since 相反）</td></tr><tr><td align="left">Max-Forwards</td><td align="left">最大传输逐跳数</td></tr><tr><td align="left">Proxy-Authorization</td><td align="left">代理服务器要求客户端的认证信息</td></tr><tr><td align="left">Range</td><td align="left">只请求获取字节范围的部分资源，处理请求返回 206，不能处理时返回 200</td></tr><tr><td align="left">Referer</td><td align="left">告知服务器请求从哪发出</td></tr><tr><td align="left">TE</td><td align="left">传输编码的优先级</td></tr><tr><td align="left">User-Agent</td><td align="left">HTTP 客户端程序的信息</td></tr></tbody></table><ul><li><h4 id="Accept-用户可代理的的媒体类型"><a href="#Accept-用户可代理的的媒体类型" class="headerlink" title="Accept 用户可代理的的媒体类型"></a>Accept 用户可代理的的媒体类型</h4><p>Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的优先级，type/subtype。</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202102/read-book-diagram-http-2/http_field_accept.png" class=""><ul><li>文本类型：text/html、text/plain…</li><li>图片类型：image/jpeg、image/gif、image/png…</li><li>视频文件：video/mpeg、video/quicktime</li><li>二进制文件：application/octet-stream、application/zip…</li></ul><blockquote><p>若想要给显示的媒体类型增加优先级，可用 “;” 分隔并设置 q=[权重值] &gt; <code>[允许类型];q=[权重值]</code> 权重值范围 0~1（精确至小数点后 3 位）</p></blockquote></li><li><h4 id="Expect-期待服务器的特定行为"><a href="#Expect-期待服务器的特定行为" class="headerlink" title="Expect 期待服务器的特定行为"></a>Expect 期待服务器的特定行为</h4><p>目前规范中只规定了 “100-continue” 这一个期望条件。<br>通知接收方客户端要发送一个体积可能很大的消息体，期望收到状态码为 100 (Continue) 的临时回复。</p><blockquote><p>例如，如果请求中 Content-Length 的值太大的话，可能会遭到服务器的拒绝。<br>常见的浏览器不会发送 Expect 消息头，但是其他类型的客户端如 cURL 默认会这么做。</p></blockquote></li><li><h4 id="If-XXX-附带条件请求"><a href="#If-XXX-附带条件请求" class="headerlink" title="If-XXX 附带条件请求"></a>If-XXX 附带条件请求</h4><p>形如 <code>If-XXX</code> 格式的请求首部字段，即可称为条件请求。</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202102/read-book-diagram-http-2/http_field_if.jpg" class="" width="500"><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202102/read-book-diagram-http-2/http_field_if_match.jpg" class="" width="500"><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202102/read-book-diagram-http-2/http_field_if_modified_since.jpg" class="" width="500"></li></ul></li><li><h3 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h3><p>响应报文会使用的首部字段</p><table><thead><tr><th align="left">首部字段名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Accept-Ranges</td><td align="left">是否接受的字节范围请求</td></tr><tr><td align="left">Age</td><td align="left">推算资源创建经过时间</td></tr><tr><td align="left">ETag</td><td align="left">资源匹配信息</td></tr><tr><td align="left">Location</td><td align="left">令客户端重新定向到的 URI</td></tr><tr><td align="left">Proxy-Authenticate</td><td align="left">代理服务器对客户端的认证信息</td></tr><tr><td align="left">Retry-After</td><td align="left">对再次发起请求的时机要求</td></tr><tr><td align="left">Server</td><td align="left">HTTP 服务器的安装信息</td></tr><tr><td align="left">Vary</td><td align="left">代理服务器缓存的管理信息</td></tr><tr><td align="left">WWW-Authenticate</td><td align="left">服务器对客户端的认证信息</td></tr></tbody></table><ul><li><h4 id="ETag-实体标识"><a href="#ETag-实体标识" class="headerlink" title="ETag 实体标识"></a>ETag 实体标识</h4><p>将资源以字符串形式做唯一标识的方式，服务器会为每份资源分配对应的 ETag 值，资源更新时，ETag 同时更新。<br>分配唯一标识的目地：仅凭 URI 指定缓存资源是相当困难的。下载过程遇连接中断或再连接情况都会依照 ETag 值指定资源</p><blockquote><p>资源的 URI 相同时：如根据浏览器返回不同语言的网站时，相同 URI，ETag 不相同</p></blockquote><ul><li>强 ETag 值：不论实体发生多么细微的变化都会改变值<br><code>ETag: &quot;usagi-1234&quot;</code></li><li>弱 ETag 值：只有资源发生了根本改变，才会改变值，且会在值前附加 “W/“<br><code>ETag: W/&quot;usagi-1234&quot;</code></li></ul></li><li><h4 id="Vary-缓存控制"><a href="#Vary-缓存控制" class="headerlink" title="Vary 缓存控制"></a>Vary 缓存控制</h4><p>对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令</p></li></ul></li><li><h3 id="实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）"><a href="#实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）" class="headerlink" title="实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）"></a>实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）</h3><table><thead><tr><th align="left">首部字段名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Allow</td><td align="left">资源可支持的 HTTP 方法</td></tr><tr><td align="left">Content-Type</td><td align="left">实体主类的类型</td></tr><tr><td align="left">Content-Encoding</td><td align="left">实体主体适用的编码方式</td></tr><tr><td align="left">Content-Language</td><td align="left">实体主体的自然语言</td></tr><tr><td align="left">Content-Location</td><td align="left">替代对应资源的 URI</td></tr><tr><td align="left">Content-Length</td><td align="left">实体主体的的字节数</td></tr><tr><td align="left">Content-Range</td><td align="left">实体主体的位置范围，一般用于发出部分请求时使用</td></tr><tr><td align="left">Content-MD5</td><td align="left">实体主体的报文摘要</td></tr><tr><td align="left">Expires</td><td align="left">实体主体过期的日期时间</td></tr><tr><td align="left">Last-Modified</td><td align="left">资源的最后修改日期时间</td></tr></tbody></table></li><li><h3 id="服务-Cookie-的字段"><a href="#服务-Cookie-的字段" class="headerlink" title="服务 Cookie 的字段"></a>服务 Cookie 的字段</h3><ul><li><h4 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">Set-Cookie: status&#x3D;enable;expires&#x3D;Tue,05 Jul 2011 07:26:31 GMT;path&#x3D;&#x2F;;domail&#x3D;.example.com;<br></code></pre></td></tr></table></figure><p>Set-Cookie 字段属性</p><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">[NAME]=[VALUE]</td><td align="left">Cookie 的名称与其值</td></tr><tr><td align="left">expires=[DATE]</td><td align="left">Cookie 的有效期，默认为关闭浏览器之前</td></tr><tr><td align="left">path=[PATH]</td><td align="left">Cookie 适用路径，默认为文档所在目录</td></tr><tr><td align="left">domain=[域名]</td><td align="left">Cookie 适用域名，默认为创建 Cookie 的服务器的域名</td></tr><tr><td align="left">Secure</td><td align="left">只有 HTTPS 安全通信时才会发送 Cookie</td></tr><tr><td align="left">HttpOnly</td><td align="left">限制 Cookie 不能被 Javascript 脚本访问</td></tr></tbody></table></li></ul></li><li><h3 id="End-to-end-首部和-Hop-by-hop-首部"><a href="#End-to-end-首部和-Hop-by-hop-首部" class="headerlink" title="End-to-end 首部和 Hop-by-hop 首部"></a>End-to-end 首部和 Hop-by-hop 首部</h3><p>HTTP 首部字段将定义成缓存代理和非缓存代理的行为，分为以下 2 种类型</p><ul><li><strong>端到端首部 End-to-end Header</strong><br>此类别的首部会转发给请求/响应的最终接收目标，且必须保存在由缓存生成的响应中，规定必须被转发</li><li><strong>逐跳首部 Hop-by-hop Header</strong><br>此类别首部只对单次转发有效，会因通过缓存或代理而不再转发<blockquote><p>HTTP/1.1 之后版本中，要使用逐跳首部，需提供 Connection 字段</p></blockquote></li></ul><p>除下列 8 个首部字段外，其他所有字段都属于端到端首部<br><code>Connection</code>、<code>Keep-Alive</code>、<code>Proxy-Authenticate</code>、<code>Proxy-Authentication</code>、<code>Trailer</code>、<code>TE</code>、<code>Transfer-Encoding</code>、<code>Upgrade</code></p></li></ul></li></ul><h1 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h1><ul><li><h2 id="2XX-成功状态码-Success"><a href="#2XX-成功状态码-Success" class="headerlink" title="2XX 成功状态码 Success"></a>2XX 成功状态码 Success</h2><p>请求正常处理完毕</p><ul><li>200 OK<br>请求已成功处理</li><li>204 No Content<br>无资源</li><li>206 Partial Content<br>接受范围请求，并返回了指定范围部分的实体内容</li></ul></li><li><h2 id="3XX-重定向-Redirection"><a href="#3XX-重定向-Redirection" class="headerlink" title="3XX 重定向 Redirection"></a>3XX 重定向 Redirection</h2><p>需要进行附加操作以完成请求</p><ul><li>301 Moved Permanently<br>永久性重定向</li><li>302 Found<br>临时性重定向</li><li>303 See Other<br>看下其他 URI，如：<br>用 POST 方法访问服务端，执行后服务端返回希望客户端以 GET 方法重定向到另一个 URI 时。</li><li>304 Not Modified<br>已找到资源，但不符合请求条件</li><li>307 Temporary Redirect<br>临时性重定向，与 302 Found 有相同含义，区别在于 307 会遵照浏览器标准。</li></ul></li><li><h2 id="4XX-客户端错误-Client-Error"><a href="#4XX-客户端错误-Client-Error" class="headerlink" title="4XX 客户端错误 Client Error"></a>4XX 客户端错误 Client Error</h2><p>服务器无法处理请求</p><ul><li>400 Bad Request<br>请求报文有错误</li><li>401 Unauthorized<br>请求需要通过 HTTP 认证（BASIC 认证、DIGEST 认证）</li><li>403 Forbidden<br>请求的资源被服务器拒绝，且没有给出拒绝理由</li><li>404 Not Found<br>服务器上没有请求的资源</li></ul></li><li><h2 id="5XX-服务器错误-Server-Error"><a href="#5XX-服务器错误-Server-Error" class="headerlink" title="5XX 服务器错误 Server Error"></a>5XX 服务器错误 Server Error</h2><p>服务器处理请求错误</p><ul><li>500 Internal Server Error<br>服务器执行请求发生错误</li><li>503 Service Unavailable<br>服务器繁忙，超负载或正停机维护</li></ul></li></ul><h1 id="继续阅读"><a href="#继续阅读" class="headerlink" title="继续阅读"></a>继续阅读</h1><ul><li><a href="/202103/read-book-diagram-http-3/" title="读记《图解HTTP》Web服务器与HTTPS">读记《图解HTTP》Web服务器与HTTPS</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
          <category> 技术类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读笔记 </tag>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读记《图解HTTP》简述网络与HTTP协议</title>
      <link href="202102/read-book-diagram-http-1/"/>
      <url>202102/read-book-diagram-http-1/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202102/read-book-diagram-http-1/cover.png" class="" width="0" height="0"><h1 id="TCP-IP-协议族"><a href="#TCP-IP-协议族" class="headerlink" title="TCP/IP 协议族"></a>TCP/IP 协议族</h1><p>计算机及网络设备间的相互通信，需要基于相同的方法。就如同与人沟通的前提是基于一种双方都会的语言一样；TCP/IP 就是互联网相关连的协议集合总称，其包括了 TCP、UDP、HTTP、FTP 等。</p><h2 id="TCP-IP-协议族的分层管理"><a href="#TCP-IP-协议族的分层管理" class="headerlink" title="TCP/IP 协议族的分层管理"></a>TCP/IP 协议族的分层管理</h2><p>TCP/IP 协议族的层次分应用层、传输层、网络层和数据链路层，其各层的作用如下：</p><ol><li>应用层：决定了向用户提供的应用服务时通信活动，如（HTTP,FTP）</li><li>传输层：对应用层提供网络连接中的的数据传输，存在两个性质不同的协议：TCP 与 UDP</li><li>网络层：用来处理网络上流动的数据包，规定了数据包的传输路线</li><li>链路层：处理连接网络的硬件部分。包括控制操作系统、硬件设计驱动、网卡及光纤等物理可见部分。</li></ol><blockquote><p>TCP/IP 的层次化可以让设计协议时相对简单，各层各司其职，更换时也仅需替换需变动的层即可。</p></blockquote><h2 id="TCP-IP-传输流"><a href="#TCP-IP-传输流" class="headerlink" title="TCP/IP 传输流"></a>TCP/IP 传输流</h2><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202102/read-book-diagram-http-1/tcp-ip_transform_flow.png" class="" width="500"><p>如上图所示：<br>发送端会由应用层向下添加每层的首部，再由接收端从链路层向上读取首部及删除每层首部</p><h1 id="与-HTTP-关系密切的协议：-IP、TCP-和-DNS"><a href="#与-HTTP-关系密切的协议：-IP、TCP-和-DNS" class="headerlink" title="与 HTTP 关系密切的协议： IP、TCP 和 DNS"></a>与 HTTP 关系密切的协议： IP、TCP 和 DNS</h1><p>先放 HTTP 协议的传输流</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202102/read-book-diagram-http-1/http_flow.png" class=""><ul><li><h2 id="IP（Internet-Protocol）网际协议"><a href="#IP（Internet-Protocol）网际协议" class="headerlink" title="IP（Internet Protocol）网际协议"></a>IP（Internet Protocol）网际协议</h2><p>属于网络层，几乎所有的网络系统都会用到 IP 协议；<br>IP 协议的作用是把各种数据包传送给对方。需要满足各类条件；其中两个重要条件就是 <code>IP地址</code> 与 <code>MAC地址</code></p><ul><li>IP 地址：指节点被分配到的地址，可发生变换。</li><li>MAC 地址：网卡出厂时固定的地址，基本上不会更改。</li></ul></li></ul><blockquote><p>IP 与 IP 地址 的含义：IP 是指协议，IP 地址是指节点被分配到的地址。</p></blockquote><ul><li><h2 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h2><p>IP 协议依赖于 MAC 地址，但通信双方在同一局域网（LAN）内的情况很少，通常需要经过多台的计算机与网络设备中转才能连接到双方。<br>ARP 协议的功能主要是将 IP 地址解析为 MAC 地址，当前域下无法解析及交给路由进行中转至下一个路由解析，直至获取 MAC 地址成功。</p></li><li><h2 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h2><p>TCP 协议位于传输层，提供可靠的字节流服务（Byte Stream Service）。为确保数据准确可靠的传给对方，TCP 协议将大数据分割，并确认最终是否送达。</p><p>TCP 协议采用三次握手策略。以确保信息完整送达给接收方</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202102/read-book-diagram-http-1/tcp_three_way_handshaking.jpg" class="" width="500"></li><li><h2 id="DNS-协议"><a href="#DNS-协议" class="headerlink" title="DNS 协议"></a>DNS 协议</h2><p>DNS 服务与 HTTP 协议一同位于应用层的协议。它提供域名到 IP 地址的解析服务。</p></li></ul><h1 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h1><blockquote><p>URI 格式：<br>    <a href="https://user:pass@www.example.com:80/dir/index.html?uid=1#hash">https://user:pass@www.example.com:80/dir/index.html?uid=1#hash</a><br>    [协议名]://[认证信息]@[服务器地址]:[端口]/[文件路径]?[查询字符串]#[片段标识符]</p></blockquote><h1 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h1><p>请求访问文本或图像等资源的一端为客户端，提供资源响应的一端称为服务器端。HTTP 协议会明确区分客户端方与服务端方<br>请求必定是由客户端发出后服务端回应返回资源</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202102/read-book-diagram-http-1/http_communicate.png" class=""><h1 id="HTTP-方法"><a href="#HTTP-方法" class="headerlink" title="HTTP 方法"></a>HTTP 方法</h1><table><thead><tr><th align="left">方法</th><th align="left">描述</th><th align="left">HTTP 版本支持</th></tr></thead><tbody><tr><td align="left">GET</td><td align="left">传输内容消息、返回访问的资源</td><td align="left">1.0/1.1</td></tr><tr><td align="left">POST</td><td align="left">传输内容消息</td><td align="left">1.0/1.1</td></tr><tr><td align="left">HEAD</td><td align="left">获取报文首部，用于确认 URI 有效性及资源更新日期</td><td align="left">1.0/1.1</td></tr><tr><td align="left">PUT</td><td align="left">传输文件（因不带验证机制，存在安全性问题，配合 REST 标准运用可开放）</td><td align="left">1.0/1.1</td></tr><tr><td align="left">DELETE</td><td align="left">删除文件，同 PUT 一样不带验证机制，需配合 REST 开放</td><td align="left">1.0/1.1</td></tr><tr><td align="left">OPTIONS</td><td align="left">访问支持的方法</td><td align="left">1.1</td></tr><tr><td align="left">TRACE</td><td align="left">追踪路径，因易引发 XST 攻击，通常不用</td><td align="left">1.1</td></tr><tr><td align="left">CONNECT</td><td align="left">与代理服务器通信时建立隧道，WEB 开发中基本用不上</td><td align="left">1.1</td></tr></tbody></table><blockquote><p>扩展阅读：<a href="https://zhuanlan.zhihu.com/p/61990354">TRACE XST 攻击原理</a> | <a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1105000713418592">REST</a></p></blockquote><h1 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h1><p>最初的 HTTP 协议因仅需满足很小的文本传输，所以每进行一次 HTTP 通信就会断开一次，现代网页包含了更大的文本传输及资源传输，会造成较大的通信量开销。</p><p>为此 <code>HTTP/1.1</code>及<code>部分的HTTP/1.0</code> 制定了持久连接的方法；只要做任意一端未明确提出断开连接，则保持 TCP 连接状态。</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202102/read-book-diagram-http-1/http_keep_alive.png" class="" width="500"><blockquote><p>HTTP/1.1 中，所有的连接默认都是持久连接，但 HTTP/1.0 内并未标准化，一部分服务器通过非标准手段实现了持久连接，但持久连接需要客户端与服务端的同时支持。</p></blockquote><ul><li><h2 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h2>可同时并行发送多个请求，不用等待响应即可发送下一个请求<img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202102/read-book-diagram-http-1/http_pipelining.jpg" class=""></li></ul><h1 id="Cookie-状态管理"><a href="#Cookie-状态管理" class="headerlink" title="Cookie 状态管理"></a>Cookie 状态管理</h1><p>HTTP 为无状态协议，它不对之前发生的请求和响应状态进行管理，将各客户端的状态都存读在服务端，服务器自然也是伤不起的。<br>因 HTTP 协议 本身非常简单的，所以才被多种场景应用。在保留无状态协议特征同时引入了 Cookie 技术。</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202102/read-book-diagram-http-1/http_cookie.png" class=""><p>Cookie 会根据从服务器发送的响应报文内增加 Set-Cookie 首部字段信息，通知客户端存储，当客户端发出下一次的请求时，存储的 Cookie 会自动加入到请求报文中发送出去。</p><ol><li><strong>请求报文</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">get &#x2F;reader HTTP&#x2F;1.1<br>Host example.com<br>#首部字段内无Cookie相关信息<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>响应报文</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">HTTP&#x2F;1.1 200 OK<br>Date: Thu, 12 Jul 2012 07:12:20 GMT<br>Server: Nginx<br>&lt;Set-Cookie:sid&#x3D;123456789;path&#x3D;&#x2F;;expires&#x3D;Wed,10-Oct-12 07:12:20 GMT&gt;<br>Content-Type: text&#x2F;plain; charset&#x3D;UTF-8<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>请求报文</strong>(自动发送保存的 Cookie 信息)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">get &#x2F;reader HTTP&#x2F;1.1<br>Host example.com<br>Cookie:sid&#x3D;123456789<br></code></pre></td></tr></table></figure><h1 id="继续阅读"><a href="#继续阅读" class="headerlink" title="继续阅读"></a>继续阅读</h1><ul><li><a href="/202102/read-book-diagram-http-2/" title="读记《图解HTTP》HTTP报文与状态码">读记《图解HTTP》HTTP报文与状态码</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
          <category> 技术类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读笔记 </tag>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vuex实现历史记录</title>
      <link href="202101/vuex-develop-history/"/>
      <url>202101/vuex-develop-history/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202101/vuex-develop-history/cover.png" class="" width="0" height="0"><p>最近自研着一个可视化操作平台，其中涉及到用户操作后可撤销或重做，在网上搜了一些解决思路，完善自己所设想的解决思路。</p><h2 id="历史记录需求的要点"><a href="#历史记录需求的要点" class="headerlink" title="历史记录需求的要点"></a>历史记录需求的要点</h2><ul><li>可存储在 localStorage 中</li><li>可多次撤销或多次重做</li><li>点击列表中的一项，将历史倒退或前进至指定位置</li></ul><p>看似简单的需求，在基础建设设计上的错误，亦会在未来导致更多的工作量。所以结合上面两点的要求，发现 vuex 的基本思路非常适合完成这个需求，redux 同样。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><blockquote><p>此项目用了 typescript 来加强代码的严谨性，方便日后维护，大家简单看个思路。</p></blockquote><h3 id="1-先定义历史记录的数据结构"><a href="#1-先定义历史记录的数据结构" class="headerlink" title="1. 先定义历史记录的数据结构"></a>1. 先定义历史记录的数据结构</h3>  <figure class="highlight typescript"><figcaption><span>vue.d.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> HistoryItem &#123;<br>  timestrap: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 记录时间戳</span><br>  name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 记录名称</span><br>  redo: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 重做Mutation</span><br>  undo: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 撤销Mutation</span><br>  redoParams: <span class="hljs-built_in">any</span>[]; <span class="hljs-comment">// 重做Mutation提交参数</span><br>  undoParams: <span class="hljs-built_in">any</span>[]; <span class="hljs-comment">// 撤销Mutation提交参数</span><br>&#125;<br><br><span class="hljs-keyword">interface</span> HistoryStatus &#123;<br>  historys: HistoryItem[]; <span class="hljs-comment">// 记录history数组</span><br>  _currentHistory: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 当前节点索引</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-编写-History-状态模块"><a href="#2-编写-History-状态模块" class="headerlink" title="2. 编写 History 状态模块"></a>2. 编写 History 状态模块</h3><p>  编写基础操作history状态的vuex <code>module</code>，创建记录的<code>Mutation</code>，重做和撤销的Action</p><blockquote><p>一条记录是包含对这个步骤的执行<code>redo</code>操作与撤销<code>undo</code>操作的。所以在用户点击列表其中一项时，应该是循环回退到当前项的前一项undo，或循环redo到当前项<br>所以需要增加一条空记录，方便用户点击空记录撤销最初的操作。</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202101/vuex-develop-history/history_dialog.png" class=""><p>运用了<code>vuex-module-decorators</code> 装饰器，写更易维护的代码</p></blockquote>  <figure class="highlight typescript"><figcaption><span>store/modules/History.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; VuexModule, Module, Mutation, Action &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vuex-module-decorators&quot;</span>;<br><br><span class="hljs-meta">@Module</span>(&#123; <span class="hljs-attr">namespaced</span>: <span class="hljs-literal">true</span> &#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HistoryModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">VuexModule</span>&lt;<span class="hljs-title">HistoryStatus</span>&gt; <span class="hljs-title">implements</span> <span class="hljs-title">HistoryStatus</span> </span>&#123;<br>  <span class="hljs-comment">/** </span><br><span class="hljs-comment">   * 初始化一个空记录的原因主要是方便列表操作时：</span><br><span class="hljs-comment">   * 当用户点击最早的一条记录时，可以正常撤销用户操作的第一步</span><br><span class="hljs-comment">  **/</span><br>  <span class="hljs-keyword">public</span> historys: HistoryItem[] = [<br>    &#123;<br>      name: <span class="hljs-string">`打开`</span>,<br>      timestrap: <span class="hljs-built_in">Date</span>.now(),<br>      redo: <span class="hljs-string">&quot;&quot;</span>,<br>      redoParams: [],<br>      undo: <span class="hljs-string">&quot;&quot;</span>,<br>      undoParams: [],<br>    &#125;,<br>  ];<br>  <span class="hljs-keyword">public</span> _currentHistory: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// getter</span><br>  <span class="hljs-keyword">get</span> <span class="hljs-title">current</span>()&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._currentHistory;<br>  &#125;<br><br>  <span class="hljs-comment">// getter</span><br>  <span class="hljs-keyword">get</span> <span class="hljs-title">historyList</span>(): <span class="hljs-title">HistoryItem</span>[] &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.historys || [];<br>  &#125;<br><br>  <span class="hljs-comment">// 创建历史记录</span><br>  <span class="hljs-meta">@Mutation</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">CREATE_HISTORY</span>(<span class="hljs-params">payload: HistoryItem</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>._currentHistory &lt; <span class="hljs-built_in">this</span>.historys.length - <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-built_in">this</span>.historys = <span class="hljs-built_in">this</span>.historys.slice(<span class="hljs-number">0</span>, <span class="hljs-built_in">this</span>._currentHistory);<br>    &#125;<br>    <span class="hljs-comment">// 由于js的深浅拷贝问题，所以在创建时都需要对数据进行深拷贝</span><br>    <span class="hljs-comment">// 想尝试lodash的clone函数，但发现好像JSON.stringify的方式clone应该更快的，毕竟我们的数据不存在函数</span><br>    <span class="hljs-comment">// 我这里就先不改了，主要是表达出思路即可</span><br>    <span class="hljs-built_in">this</span>.historys.push(_.cloneDeep(payload));<br>    <span class="hljs-built_in">this</span>._currentHistory = <span class="hljs-built_in">this</span>.historys.length - <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-meta">@Mutation</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">SET_CURRENT_HISTORY</span>(<span class="hljs-params">index: <span class="hljs-built_in">number</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>._currentHistory = index &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : index;<br>  &#125;<br><br>  <span class="hljs-comment">// 重做</span><br>  <span class="hljs-meta">@Action</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">RedoHistory</span>(<span class="hljs-params">times: <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span></span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> &#123; state, commit &#125; = <span class="hljs-built_in">this</span>.context;<br>    <span class="hljs-keyword">let</span> historys: HistoryItem[] = state.historys;<br>    <span class="hljs-keyword">let</span> current: <span class="hljs-built_in">number</span> = state._currentHistory;<br>    <span class="hljs-keyword">if</span> (current + times &gt;= historys.length) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">while</span> (times &gt; <span class="hljs-number">0</span>) &#123;<br>      current++;<br>      <span class="hljs-keyword">let</span> history = historys[current];<br>      <span class="hljs-keyword">if</span> (history) &#123;<br>        commit(history.redo, ...history.redoParams, &#123; <span class="hljs-attr">root</span>: <span class="hljs-literal">true</span> &#125;);<br>      &#125;<br>      times--;<br>    &#125;<br>    commit(<span class="hljs-string">&quot;SET_CURRENT_HISTORY&quot;</span>, current);<br>  &#125;<br><br>  <span class="hljs-comment">// 撤销</span><br>  <span class="hljs-meta">@Action</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">UndoHistory</span>(<span class="hljs-params">times: <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span></span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> &#123; state, commit &#125; = <span class="hljs-built_in">this</span>.context;<br>    <span class="hljs-keyword">let</span> historys: HistoryItem[] = state.historys;<br>    <span class="hljs-keyword">let</span> current: <span class="hljs-built_in">number</span> = state._currentHistory;<br>    <span class="hljs-keyword">if</span> (current - times &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">while</span> (times &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">let</span> history = historys[current];<br>      <span class="hljs-keyword">if</span> (history) &#123;<br>        commit(history.undo, ...history.undoParams, &#123; <span class="hljs-attr">root</span>: <span class="hljs-literal">true</span> &#125;);<br>      &#125;<br>      times--;<br>      current--;<br>    &#125;<br>    commit(<span class="hljs-string">&quot;SET_CURRENT_HISTORY&quot;</span>, current);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-编写可以撤销或重做的功能"><a href="#3-编写可以撤销或重做的功能" class="headerlink" title="3. 编写可以撤销或重做的功能"></a>3. 编写可以撤销或重做的功能</h3><p>  完成上面两步后，我们就可以编写各种操作了</p><ol><li><p>编写对数据基础操作的<code>Mutation</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Mutation</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">CREATE_PAGE</span>(<span class="hljs-params">payload: &#123; page: PageItem; index: <span class="hljs-built_in">number</span> &#125;</span>)</span> &#123;<br>  <span class="hljs-built_in">this</span>.pages.splice(payload.index, <span class="hljs-number">0</span>, _.cloneDeep(payload.page));<br>  <span class="hljs-built_in">this</span>._currentPage = <span class="hljs-built_in">this</span>.pages.length - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-meta">@Mutation</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">REMOVE_PAGE</span>(<span class="hljs-params">id: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>  <span class="hljs-keyword">let</span> index = <span class="hljs-built_in">this</span>.pages.findIndex(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> p.id == id);<br>  index &gt; -<span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">this</span>.pages.splice(index, <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>._currentPage == index) &#123;<br>    <span class="hljs-built_in">this</span>._currentPage = <span class="hljs-built_in">this</span>.pages.length &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : -<span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>将基础操作按要求封装成带保存-&gt;记录-&gt;执行的<code>Action</code></p><figure class="highlight typescript"><figcaption><span>store/modules/Page.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 包装创建页面函数</span><br><span class="hljs-meta">@Action</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">CreatePage</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>: <span class="hljs-string">&quot;page&quot;</span> | <span class="hljs-string">&quot;dialog&quot;</span></span>)</span> &#123;<br>  <span class="hljs-keyword">let</span> &#123; state, commit &#125; = <span class="hljs-built_in">this</span>.context;<br>  <br>  <span class="hljs-comment">// 记录保存即将创建的页面</span><br>  <span class="hljs-keyword">let</span> id = _.uniqueId(<span class="hljs-keyword">type</span>) + <span class="hljs-built_in">Date</span>.now();<br>  <span class="hljs-keyword">let</span> pageName = pageType[<span class="hljs-keyword">type</span>];<br>  <span class="hljs-keyword">let</span> page: PageItem = &#123;<br>    id,<br>    name: <span class="hljs-string">`<span class="hljs-subst">$&#123;pageName&#125;</span><span class="hljs-subst">$&#123;state.pages.length + <span class="hljs-number">1</span>&#125;</span>`</span>,<br>    <span class="hljs-keyword">type</span>,<br>    layers: [],<br>    style: &#123; <span class="hljs-attr">width</span>: <span class="hljs-number">720</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">1280</span> &#125;,<br>  &#125;;<br><br>  <span class="hljs-comment">//创建历史记录</span><br>  <span class="hljs-keyword">let</span> history: HistoryItem = &#123;<br>    name: <span class="hljs-string">`创建<span class="hljs-subst">$&#123;pageName&#125;</span>`</span>,<br>    timestrap: <span class="hljs-built_in">Date</span>.now(),<br>    redo: <span class="hljs-string">&quot;Page/CREATE_PAGE&quot;</span>,<br>    redoParams: [&#123; <span class="hljs-attr">index</span>: state.pages.length - <span class="hljs-number">1</span>, page &#125;],<br>    undo: <span class="hljs-string">&quot;Page/REMOVE_PAGE&quot;</span>,<br>    undoParams: [id],<br>  &#125;;<br>  <span class="hljs-comment">// 保存记录此历史记录</span><br>  commit(<span class="hljs-string">&quot;Histroy/CREATE_HISTORY&quot;</span>, history, &#123; <span class="hljs-attr">root</span>: <span class="hljs-literal">true</span> &#125;);<br><br>  commit(history.redo, ...history.redoParams, &#123; <span class="hljs-attr">root</span>: <span class="hljs-literal">true</span> &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><figcaption><span>store/modules/Page.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Action</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">RemovePage</span>(<span class="hljs-params">id: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>  <span class="hljs-comment">// 记录保存现场状态</span><br>  <span class="hljs-keyword">let</span> index = <span class="hljs-built_in">this</span>.pages.findIndex(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> p.id == id);<br>  <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">let</span> page: PageItem = <span class="hljs-built_in">this</span>.context.state.pages[index];<br><br>  <span class="hljs-comment">//创建历史记录</span><br>  <span class="hljs-keyword">let</span> history: HistoryItem = &#123;<br>    name: <span class="hljs-string">`删除 <span class="hljs-subst">$&#123;page.name&#125;</span>`</span>,<br>    timestrap: <span class="hljs-built_in">Date</span>.now(),<br>    redo: <span class="hljs-string">&quot;Page/REMOVE_PAGE&quot;</span>,<br>    redoParams: [id],<br>    undo: <span class="hljs-string">&quot;Page/CREATE_PAGE&quot;</span>,<br>    undoParams: [&#123; page, index &#125;],<br>  &#125;;<br><br>  <span class="hljs-comment">// 保存记录此历史记录</span><br>  <span class="hljs-built_in">this</span>.context.commit(<span class="hljs-string">&quot;Histroy/CREATE_HISTORY&quot;</span>, history, &#123; <span class="hljs-attr">root</span>: <span class="hljs-literal">true</span> &#125;);<br>  <span class="hljs-built_in">this</span>.context.commit(history.redo, ...history.redoParams, &#123; <span class="hljs-attr">root</span>: <span class="hljs-literal">true</span> &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上，撤销与重做的功能就基本完成了</p><h3 id="4-使用"><a href="#4-使用" class="headerlink" title="4. 使用"></a>4. 使用</h3><ol><li>我们现在只需要在使用时创建或删除页面时使用封装的<code>Action</code>后</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">create</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>: <span class="hljs-string">&quot;page&quot;</span> | <span class="hljs-string">&quot;dialog&quot;</span></span>)</span> &#123;<br>  <span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&quot;Page/CreatePage&quot;</span>, <span class="hljs-keyword">type</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">remove</span>(<span class="hljs-params">id: <span class="hljs-built_in">number</span></span>)</span> &#123;<br>  <span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&quot;Page/RemovePage&quot;</span>, id);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>配置全局热键</li></ol><figure class="highlight typescript"><figcaption><span>App.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript">...<br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">let</span> self = <span class="hljs-built_in">this</span>;<br>  hotkeys(<span class="hljs-string">&quot;ctrl+z&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event, handler</span>) </span>&#123;<br>    self.$store.dispatch(<span class="hljs-string">&quot;History/UndoHistory&quot;</span>);<br>  &#125;);<br>  hotkeys(<span class="hljs-string">&quot;ctrl+y&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event, handler</span>) </span>&#123;<br>    self.$store.dispatch(<span class="hljs-string">&quot;History/RedoHistory&quot;</span>);<br>  &#125;);<br>&#125;<br>...<br></code></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202101/vuex-develop-history/effect.gif" class=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
          <category> WEB开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vuex </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 思路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>朋友安利的一款轻量级docker容器可视化管理</title>
      <link href="202101/recommend-portainer/"/>
      <url>202101/recommend-portainer/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202101/recommend-portainer/cover.png" class="" width="0" height="0"><p>刚开始玩docker及linux玩的少我来说，有可视化的Docker管理工具真的不要太香了。</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202101/recommend-portainer/portainer.png" class=""><h1 id="安装并运行-portainer-镜像"><a href="#安装并运行-portainer-镜像" class="headerlink" title="安装并运行 portainer 镜像"></a>安装并运行 portainer 镜像</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 拉取portainer镜像</span><br>docker pull docker pull portainer/portainer-ce<br><span class="hljs-comment"># 创建 portainer_data docker volume目录</span><br>docker volume create portainer_data<br><span class="hljs-comment"># 创建运行portainer容器</span><br>docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce<br><span class="hljs-comment"># -d 后台运行</span><br><span class="hljs-comment"># -p 映射8000与9000的端口</span><br><span class="hljs-comment"># --name 容器名称</span><br><span class="hljs-comment"># --restart=always docker重启时自动启动容器</span><br><span class="hljs-comment"># -v 映射本地docker.sock 及 新创建的portainer_data volume目录</span><br></code></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>安装完成后，通过 <a href="http://ip:9000/">http://ip:9000/</a> 即可访问，设置服务的用户名密码后</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202101/recommend-portainer/set_user.png" class=""><p>前面的映射中已将docker.sock映射了，所以我们直接选择 <code>Local</code> 后 <code>connect</code> 就可以直接享用啦</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202101/recommend-portainer/bind_docker_sock.png" class="">]]></content>
      
      
      <categories>
          
          <category> 服务运维 </category>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker部署GitLab遇到的问题</title>
      <link href="202101/docker-gitlab/"/>
      <url>202101/docker-gitlab/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202101/docker-gitlab/cover.png" class="" width="0" height="0"><h1 id="啰哩啰嗦"><a href="#啰哩啰嗦" class="headerlink" title="啰哩啰嗦"></a>啰哩啰嗦</h1><p>玩上 docker 后，开始热衷于在上面架设各种服务来玩。就想着搞个 gitlab 来玩玩好了。不过我朋友也劝我没必要，因为我们个人的容灾手段还是有限的，为此，我机智的想到一招，直接镜像到 github 或者是 coding 之类的 git 平台，这样就不怕万一真出现了的数据灾难啦。<br>毕竟技术无国界还是要分情况的，github封禁伊朗籍的账户的事件还是值得警惕，虽说我个小人物，但我还是不想遇到万一需要迁移的麻烦事；代码放在自己的物理硬盘的手段还是必要的。</p><p>这篇文章主要<del>水的</del>原因在于我直接安装配置完gitlab后，遇到的几个迷之问题，与找到的解决方案。</p><ul><li><p>发现gitlab页面中部分链接总是会跳到无端口的页面中，自然也就是404了，甚至不知如何搜这个问题，在莫名的契机下，找到了解决方案，其实也是个很基础的配置问题。</p><blockquote><p><a href="https://segmentfault.com/a/1190000021229534">通过 Docker 快速部署公司内部 GitLab</a></p></blockquote></li><li><p>可能是我安装的gitlab版本问题，我的gitlab还没多少项目存放，每天却按 1G 以上的大小占用了我的硬盘，GITLAB是架设在本地机子中的 VM虚拟机的 ，暂时没空解决这个问题，就只好先对虚拟机扩容了。</p><blockquote><p>抽空后，发现gitlab应该下的prometheus文件夹大到爆炸，通过查询prometheus的必要性后，我对其直接停用处理了。</p></blockquote></li></ul><h1 id="安装并运行-gitlab-镜像"><a href="#安装并运行-gitlab-镜像" class="headerlink" title="安装并运行 gitlab 镜像"></a>安装并运行 gitlab 镜像</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 拉取gitlab镜像</span><br>docker pull gitlab/gitlab-ce<br><br><span class="hljs-comment"># 为 gitlab 创建 2 个docker volume目录： gitlab_data 和 gitlab_config</span><br>docker volume create gitlab_data<br>docker volume create gitlab_config<br><br><span class="hljs-comment"># 个人是私用的gitlab，所以端口之类自然也不可以直接用gitlab默认的。</span><br>docker run -d  -p 8443:443 -p 3300:80 -p 1011:22 --name gitlab --restart always -v gitlab_config:/etc/gitlab -v gitlab_data:/var/opt/gitlab gitlab/gitlab-ce<br><span class="hljs-comment"># -d 后台运行</span><br><span class="hljs-comment"># -p [映射端口]:[容器端口]</span><br><span class="hljs-comment"># --name 容器名称</span><br><span class="hljs-comment"># --restart=always docker重启时自动启动容器</span><br><span class="hljs-comment"># -v 映射gitlab_data和gitlab_config volume目录</span><br></code></pre></td></tr></table></figure><h1 id="配置gitlab-rb"><a href="#配置gitlab-rb" class="headerlink" title="配置gitlab.rb"></a>配置gitlab.rb</h1><p>gitlab容器运行没问题后，在gitlab上创建项目的时候，生成项目的URL访问地址是按容器的hostname来生成的，所以也就无法正常的克隆、拉取、提交了。我们还需要更新一下配置后重启gitlab</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 通过直接进入挂载文件夹修改</span><br>vim &#123;volumn_dir&#125;/gitlab_data/_data/gitlab.rb<br><br><span class="hljs-comment"># 进入容器修改</span><br>docker <span class="hljs-built_in">exec</span> -it gitlab bash<br>vim /etc/gitlab/gitlab.rb<br></code></pre></td></tr></table></figure><blockquote><p>小提示（会VIM的略过吧）：<br>按下 <code>/ 键</code> 并输入要搜索的字符后 <code>回车键</code>，<code>n 键</code> 查看下一条 <code>shift + n 键</code> 查看上一条<br>按下 <code>i 键</code> 进入编辑模式，编辑完成后 <code>Esc 键</code> 退出编辑模式<br>非编辑模式下 输入 :wq 保存文档</p></blockquote><figure class="highlight bash"><figcaption><span>gitlab.rb</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 修改如下语句</span><br>external_url <span class="hljs-string">&#x27;http://[ip/hostname]:3300&#x27;</span><br><br><span class="hljs-comment"># nginx默认会去external_url中获取端口用以访问，但我们窗口只映射了80，所以还需要nginx指向的端口到80</span><br>nginx[<span class="hljs-string">&#x27;listen_port&#x27;</span>] = 80<br><span class="hljs-comment"># https需要下面这句</span><br><span class="hljs-comment"># nginx[&#x27;redirect_http_to_https_port&#x27;] = 443</span><br><br><span class="hljs-comment"># 配置 1011 端口</span><br>gitlab_rails[<span class="hljs-string">&#x27;gitlab_shell_ssh_port&#x27;</span>] = 1011<br><span class="hljs-comment"># 停用prometheus</span><br>prometheus_monitoring[<span class="hljs-string">&#x27;enable&#x27;</span>] = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>按上述修改完成后 重启gitlab就可以啦</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker restart gitlab<br></code></pre></td></tr></table></figure><p>以上基本gitlab的访问配置就完成了。接下来就自行访问可视化配置进行配置吧。</p><h1 id="我的gitlab最终效果"><a href="#我的gitlab最终效果" class="headerlink" title="我的gitlab最终效果~"></a>我的gitlab最终效果~</h1><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202101/docker-gitlab/result.png" class="">]]></content>
      
      
      <categories>
          
          <category> 服务运维 </category>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stylus-shortcut 加速编写 CSS</title>
      <link href="202012/stylus-shortcut/"/>
      <url>202012/stylus-shortcut/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202012/stylus-shortcut/cover.png" class="" width="0" height="0"><p>stylus-shortcut 可以加速编写 CSS，通过 stylus 中 mixin 的功能，将样式常用组合合并汇以简单一句，减少代码的编写量；并通过 stylus 循环将常用主题变量生成常用的样式规则，可快捷使用。</p><ul><li><strong><a href="https://kwokronny.top/stylus-shortcut-document/">说明文档</a></strong></li><li><strong><a href="https://github.com/hiyoz/stylus-shortcut">项目仓库</a></strong></li></ul><h2 id="开发意图"><a href="#开发意图" class="headerlink" title="开发意图"></a>开发意图</h2><p>编写这个项目最初的目的是在开发一 SAAS 平台时，我已采用 iviewUI 的基础上进行开发，并通过自定义主题覆盖了部分样式及颜色变量后。常常需要在部分元素上为元素命名后仅仅为其加一项间距属性或文本颜色等简单的样式。来回切换样式文件与 DOM 文件，及为不重要的小元素命名，多而烦；或许这也是为什么 Bootstrap 可以一下成为大家热爱的库吧。</p><p>所以我简单通过 stylus 的循环按设计规范中常用的间距生成了多个间距样式及颜色样式，真的非常的方便与快落；事实证明频繁的切换文件是容易忘记自己需要做什么的。<br>再之后，为一些复杂的设计编写样式时，常常在写完 width 时基本下一句可能就是 height，嗒嗒嗒下来，写了许多行，但常常这些伴随着规律，定位时会写 left,top、宽高写完时可能还会再设置个圆角等，写了几年前端后早已厌烦了长长的样式规则。<br>所以我通过 stylus 的 mixin 功能，将编写 CSS 时常用的规律汇成一句，小小的功能，也可以提升大大的效率。<br>编写文档时，也常问自己项目如此的小，是否需要变成一个库呢？我找到了答案，小而简就是这个项目的初心，他解决的是开发中常常忽视的小烦恼，整理出规律增加编写效率也是这个小项目最重要的核心<br>如果你也同我一样存在这些厌烦，不妨试试这个库哟~</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>通过 stylus 的特性整理开发的一套加速样式编写的解决方案</li><li>可快速将设计中常用的规范转化为变量生成常用的样式</li><li>命名规则应用尊循 BEM</li><li>小而美，只解决常见但小的麻烦</li></ul><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;your-custom-variable-file.styl&quot;</span> <span class="hljs-comment">//引入自定义变量</span><br><span class="hljs-comment">// 同时引入 shortcut.styl mixin.styl</span><br><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;~@hiyoz/stylus-shortcut&quot;</span><br><span class="hljs-comment">// or 单独引入 shortcut.styl</span><br><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;~@hiyoz/stylus-shortcut/src/shortcut.styl</span><br><span class="hljs-string">// or 单独引入 mixin.styl</span><br>@import &quot;~@hiyoz/stylus-shortcut/src/mixin.styl<br></code></pre></td></tr></table></figure><blockquote><p>变量与mixin需要在多文件下自动引用可通过stylus-loader<br>如 vue-cli@3 配置示例，在 stylus-loader 中配置 import 全局引入</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//vue.config.js</span><br>modules.export=&#123;<br>  ...<br>  css: &#123;<br>    <span class="hljs-comment">// 配置css模块</span><br>    loaderOptions: &#123;<br>      <span class="hljs-comment">// 向预处理器 Loader 传递配置选项</span><br>      stylus: &#123;<br>        <span class="hljs-keyword">import</span>: [<br>          <span class="hljs-string">&quot;your-custom-variable-file.styl&quot;</span>,<br>          <span class="hljs-string">&quot;@hiyoz/stylus-shortcut/src/mixin.styl&quot;</span><br>        ]<br>      &#125;<br>    &#125;<br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs variable.styl">yoz_color &#x3D; &#123;<br>  primary: #1890ff,<br>  link: #1890ff,<br>  success: #52c41a,<br>  warning: #faad14,<br>  error: #f5222d<br>&#125;;<br>yoz_spacing ?&#x3D; &#123;<br>  &#39;5&#39;: 5px,<br>  &#39;10&#39;: 10px,<br>  &#39;20&#39;: 20px,<br>  &#39;30&#39;: 30px<br>&#125;;<br>...<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;flex-h&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text-c_primary&quot;</span>&gt;</span>文本颜色primary<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--文本颜色为变量值primary--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box bg-c_primary spac-ml_20&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--背景颜色为primary--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box bg-c_primary spac-mh_20&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--水平外间距--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box bg-c_primary spac-p_20&quot;</span>&gt;</span>内间距<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--四边内间距--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
          <category> WEB开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stylus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS预处理哪家强？</title>
      <link href="202012/css-pre-handler/"/>
      <url>202012/css-pre-handler/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202012/css-pre-handler/cover.png" class="" width="0" height="0"><h1 id="不想再回到的CSS时代"><a href="#不想再回到的CSS时代" class="headerlink" title="不想再回到的CSS时代"></a>不想再回到的CSS时代</h1><p>刚学前端时，各预处理软件还没出现，犹记得当时写的最好的 CSS格式是这样</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.panel</span>&#123; <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>; <span class="hljs-attribute">height</span>:<span class="hljs-number">800px</span>; <span class="hljs-attribute">margin</span>: <span class="hljs-number">30px</span> &#125;<br><span class="hljs-selector-class">.panel</span> <span class="hljs-selector-class">.panel-title</span>&#123; <span class="hljs-attribute">font-size</span>: <span class="hljs-number">18px</span>; <span class="hljs-attribute">font-weight</span>:bold; &#125;<br></code></pre></td></tr></table></figure><p>在当时CSS不支持嵌套的时代，这样的CSS规则已经算是简单易看懂的了，但在浏览器商开始逐鹿时，被样式<code>-webkit-</code>、<code>-moz-</code>等前缀弄到臃肿难受。</p><h1 id="各大预处理器的出现"><a href="#各大预处理器的出现" class="headerlink" title="各大预处理器的出现"></a>各大预处理器的出现</h1><p>为了解决日益复杂的交互需求，及更规范的前端工程化，伟大的先驱们开发了许许多多加速工作效率解决方案。</p><p>各大CSS预处理器出现后，我基本每款都在项目中实践应用过，就说说他们的优劣势水水文吧。</p><blockquote><p>产品的优劣很多时候是针对需求而言的，所以以下优劣仅以是针对我个人而言，供大家参考。</p></blockquote><h2 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h2><p>个人最开始使用的预处理语言，当时的 webpack 在我身边刚开始普及，大部分还主要是gulp、grunt的天下，我的前端视界也还未被打开，前后端处于半分离的模式，由后端渲染页面，前端部分交互由接口完成。开始接触到Less的我觉得方便极了，拥有常见的变量，函数，导入，混合，逻辑运算、嵌套等功能，这些功能极大的减少了CSS的编写量，算是非常轻量好上手的预处理工具了。</p><h2 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h2><p>接触Less的同时也了解到有Sass这个更强大的预处理器。但个人对webpack及前端项目工程化还不太熟悉的我先选择了less做为入门先，有了基本的前端工程化思维后才正式开始使用Sass开发项目；Sass给我的感觉是在逻辑运算上，自定义函数等多方面更优于Less，但语法复杂度确实相较于Less难上手许多，语法也更为严谨，但对于个人对CSS预处理器的期望需求仅仅是完成变量，循环，模块化CSS，自定义函数等功能的我来说。Sass过于臃肿，最大烦恼莫过于npm安装时，node-sass在国内环境下无法正常安装，经常出现超时等无法安装的问题，虽说找到过解决方案，但实在是令人难受，CSS作为WEB界面配置的其中一环，使用一门如此麻烦严谨的语言，实在是有些难以接受。</p><h2 id="Stylus"><a href="#Stylus" class="headerlink" title="Stylus"></a>Stylus</h2><p>一次机缘巧合下，接触到了一个项目，项目中运用的CSS预处理语言独树一帜，无花括号，无分号等；其实早前了解时有知道过这个stylus，但当时主要展示的是无花括号及分号的写法，个人到现在其实都不太相信，因为没有界限及通过制表符完成嵌套等语句功能，实在时太容易出问题了。对于文件编码及换行符的未深入了解的鸵鸟人来说。这种不确定性我还是想避免的。事实证明，在刚开始接触这种写法时，还是挺爽的，但可能mac上打的一个奇怪的空格，或换行符等问题，会让你摸不着头脑的找不到出问题的位置。</p><blockquote><p>但这个语言其实亦支持使用花括号及分号，只需要配置格式化工具即可，这样就再也不会有那种因编码等导致的令人头大的问题了</p></blockquote><p><strong>VS Code中的格式化插件是：<a href="https://marketplace.visualstudio.com/items?itemName=thisismanta.stylus-supremacy">Manta’s Stylus Supremacy</a></strong></p><p>至此，这款stylus便是我最爱用的一款预处理工具了，如less般好上手，拥有sass般强大的功能，逻辑循环等语法简单且像js，支持集合变量等，让人爱不释手。下面是我最近有整合的stylus-shortcut库中部分代码，可以通过变量快速完成一套bootstrap式的CSS规则，快速应用。</p><blockquote><a href="/202012/stylus-shortcut/" title="stylus-shortcut 加速编写 CSS">stylus-shortcut 加速编写 CSS</a></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-class">.flex</span> &#123;<br><span class="hljs-variable">$flex_direction</span> = &#123;<br>h: row,<br>h_rtl: row-reverse,<br>v: column,<br>v_rtl: column-reverse<br>&#125;;<br><br><span class="hljs-keyword">for</span> <span class="hljs-variable">$name</span>, <span class="hljs-variable">$value</span> <span class="hljs-keyword">in</span> <span class="hljs-variable">$flex_direction</span> &#123;<br>&amp;-&#123;<span class="hljs-variable">$name</span>&#125; &#123;<br><span class="hljs-attribute">display</span>: flex;<br><span class="hljs-attribute">flex-direction</span>: <span class="hljs-variable">$value</span>;<br>&#125;<br>&#125;<br>&#125;<br><br>yoz_text_align = &#123;<br>  l: <span class="hljs-attribute">left</span>,<br>  r: <span class="hljs-attribute">right</span>,<br>  c: center,<br>  j: justify<br>&#125;;<br><br><span class="hljs-keyword">for</span> <span class="hljs-variable">$name</span>, <span class="hljs-variable">$value</span> <span class="hljs-keyword">in</span> yoz_text_align &#123;<br>  .text-a_&#123;<span class="hljs-variable">$name</span>&#125; &#123;<br>    <span class="hljs-attribute">text-align</span>: <span class="hljs-variable">$value</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> 杂文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安利一款免费好用的开源密码管理软件 - KeePassXC</title>
      <link href="202011/recommend-keepass/"/>
      <url>202011/recommend-keepass/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/cover.png" class="" width="0" height="0"><h2 id="用过的密码管理软件"><a href="#用过的密码管理软件" class="headerlink" title="用过的密码管理软件"></a>用过的密码管理软件</h2><p>推荐前先介绍自己在密码管理上经历过的历程，无兴趣可直接跳过这一段</p><ol><li><h3 id="级别密码制"><a href="#级别密码制" class="headerlink" title="级别密码制"></a>级别密码制</h3><p>统一三个级别的密码，分为：无隐私风险，轻隐私风险，重度隐私风险的密码，密码复杂度按级别升高。方便，只用记三个密码即可尽可能的保护自己的隐私和方便自己的记忆。</p></li><li><h3 id="lastpass"><a href="#lastpass" class="headerlink" title="lastpass"></a>lastpass</h3><p><code>超能小紫</code>最早推荐我用的密码管理的 CHORME 扩展，后来也因为曝出过相关的密码泄漏新闻，所以就试着找个安全些的。</p></li><li><h3 id="1Password"><a href="#1Password" class="headerlink" title="1Password"></a>1Password</h3><p>同样是<code>超能小紫</code>给我安利的，刚好试着免费试用 1 年，试用了几个月，个人在使用上感觉在交互还是不太喜爱，各平台的操作相对不统一，密码生成、删除，修改等操作上有些麻烦，特别是我在新平台注册活登陆时不会自动收集我的信息询问我是否存储，不知是不是我没配置好；这样想想订阅费用还是让我稍稍心痛的。</p></li></ol><h2 id="正式安利-KeePass"><a href="#正式安利-KeePass" class="headerlink" title="正式安利 - KeePass"></a>正式安利 - KeePass</h2><p>KeePass 起初真只是抱着试试的心态，毕竟大概如果有了解的话，KeePass 的相关官网包括网上许多的使用文档中的软件截图，界面风格跟 2000 年基本无异了；我主要电脑是 MacBook 的，一开始还真没打算用这套全平台解决方案，想着再找找，但突然认真看了下网站，发现开源的项目，都有着伟大的开源精神的程序员圈子，一个平台出现了三四种基于 keepass 的第三方版本及各种原生插件。</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/main_big.png" class=""><p>官方版本 KeePass</p><ol><li><h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3>开始试着把以前的密码数据导出后，开始试着转移密码到这个新的解决方案的载体时，官方提供的各平台版本，其实在交互上及实用性上都确认不及<code>1Password</code>所带出的基本功能，各平台间交互差异大，且直接无浏览器扩展的支持，有的也只是已从谷歌官方应用扩展商店下架后，博主间传出的离线版本了；所以还真有点想放弃，老实交钱用回<code>1Password</code>了。</li></ol><blockquote><p>就在我准备放弃前，多搜索了一次。我拥抱了开源<del>穷逼不配1password</del></p></blockquote><ol start="2"><li><h3 id="发现宝藏"><a href="#发现宝藏" class="headerlink" title="发现宝藏"></a>发现宝藏</h3>在一次无意的搜索中，我发现了这款基于<code>KeePass</code>开发的第三方全平台支持的软件版本<a target="_blank" href="https://keepassxc.org/"><center><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/keepassxc-logo.svg" class="" width="100"></center><center style="color:#30782f">KeePassXC</center></a></li></ol><p>一起先看看的截图</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/welcome_screen.png" class=""><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/database_view.png" class=""><h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2><ol><li><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>再放置个<a href="https://keepassxc.org/"><strong>传送门</strong></a><br>根据自己的系统下载匹配的<code>KeePassXC</code>软件,</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/download_page.png" class=""><p>下载后按系统常用方式安装软件即可。</p></li><li><h3 id="生成密码库文件"><a href="#生成密码库文件" class="headerlink" title="生成密码库文件"></a>生成密码库文件</h3><blockquote><p>已用 KeePass 或其他第三方基于 KeePass 的软件生成的密码文件，可跳过此步骤，直接打开食用<br>安装完成后并打开后，如下图所示（软件语言多种，默认跟随系统语言）</p></blockquote><ol><li><p>点击 <code>新建数据库/Create new database</code> 弹出新建窗口</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/welcome_screen.png" class=""></li><li><p>填写数据库名称，点击下一步。</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/create_lib.png" class=""></li><li><p>加密设置，此步骤可直接下一步，亦可详细了解下，毕竟我的隐私不涉及 PY 交易，所以加密复杂度正常就好。（后面想改也可以改）</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/setting_encrypt.png" class=""></li><li><p>密码设置，输入你的主密码，及再次输入后，确认并保存到存储的位置就完成啦。 &gt; 数据库的钥匙，唯一要记住的密码，每次数据库因限定时间未使用时或锁屏离开后锁定时，都需要输入这个密码解锁使用存储的密码。（主密码最好定期更换），有条件的亦可增加硬件设备使用，增强安全性。</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/setting_main_password.png" class=""></li><li><p><strong>最后一个大问题</strong>：密码的存放</p></li></ol><p>因需要多平台使用，密码库的同步尤为重要；需要借助云盘完成。（当然，亦可以自架服务存储并使用）</p><p>推荐云盘：<code>oneDriver</code></p><p>那同步的位置好了后，接下来就只用把生成好的数据库文件放到云盘就 OK 啦。</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/icloud.png" class=""></li><li><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li>查看设置项，设置项可根据自己的习惯配置，我就不一一说明了。</li></ol><blockquote><p>其中需要注意的是 常规-&gt;基础设置-&gt;用户界面 记得勾选<code>最小化而不是退出应用程序</code>，保持程序启动。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/base_setting.png" class=""><ol start="2"><li>下载浏览器扩展并配置连接数据库</li></ol><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/setting_browser.png" class=""><p>如上图按需配置，并按所用的浏览器下载对应的扩展。进入浏览器扩展进行配置绑定即可</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/bind_browser.jpg" class=""><ol start="3"><li>当我们打开浏览器登陆时，KeePassXC 会通过匹配链接后询问是否授权信息，确认后，当只有一个密码时就会直接自动输入到输入框了，该平台有多个账号时亦可点击输入框后切换。</li></ol><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/browser_request.png" class=""><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/browser_input.png" class=""><p>还有更多的细节等待你的摸索啦~</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雪碧图命令行工具开源</title>
      <link href="202011/sprites-cli-develop/"/>
      <url>202011/sprites-cli-develop/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/sprites-cli-develop/cover.png" class="" width="0" height="0"><h2 id="小图的烦恼"><a href="#小图的烦恼" class="headerlink" title="小图的烦恼"></a>小图的烦恼</h2><p>项目中经常有不可避免的出现小图标，雪碧图依然是很多团队的选择，网上也有了各种各样的雪碧图插件或方案等。但大多数仅仅实现了简易的拼图及规则生成，我在项目中常常遇到两个小图需要在用户交互时切换等甚至更为复杂的需求；终于在百忙<del>懒癌绝症</del>之中搞了一个生成雪碧图的命令行小工具，望大家参考指教。</p><p><a href="https://github.com/hiyoz/sprites-cli">传送门</a></p><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><ul><li><h3 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h3></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install @hiyoz/sprite-cli -g<br><br>sprites-cli [options]<br><br>通过命令对指定目录下的所有结尾 -sprite 结束的雪碧图文件夹，生成雪碧图到指定的生成目录，并生成雪碧图的对应样式文件。支持不同文件夹自定义CSS样式<br><br>Options:<br>  -s, --scope [value]  [必填]设定范围目录，范围目录下所有结尾 -sprite 结束的雪碧图文件夹<br>  -r, --rule [value]   生成sheet规则版本: css less scss stylus，默认使用css若 优先使用雪碧图文件夹下有 template.js 生成规则脚本<br>  -d, --dist [value]   生成目录[范围目录的相对路径]，默认 <span class="hljs-string">&quot;./&quot;</span><br></code></pre></td></tr></table></figure><ul><li><h3 id="基础使用示例"><a href="#基础使用示例" class="headerlink" title="基础使用示例"></a>基础使用示例</h3><p>  <code>demo</code>目录下<code>galaxy-sprite</code>存储了等待合成的雪碧图原料。希望生成stylus的CSS规则文件</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sprites-cli -s demo -r stylus<br></code></pre></td></tr></table></figure><p>  通过命令即可在demo目录下生成galaxy-sprite.styl与galaxy-sprite.png文件。</p></li><li><h3 id="自定义样式生成"><a href="#自定义样式生成" class="headerlink" title="自定义样式生成"></a>自定义样式生成</h3><p>  部分雪碧图在使用时希望支持一定的交互效果，如：某图标在移过去时变换成另一个图标时；即可通过自定义样式生成的方案，在自定义生成符合需求的CSS规则。</p><p>  仅需将在 相应的雪碧图文件夹内 如：<code>[name]-sprite</code>文件夹下，创建<code>template.js</code>文件，代码如下：</p><blockquote><p>当雪碧图文件夹下存在<code>template.js</code>时，该雪碧图文件夹的CSS规则生成仅以此为唯一的生成规则</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">spritesheet</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> spritesCSS = <span class="hljs-string">``</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(spritesheet.sprites)) &#123;<br>    spritesCSS = spritesheet.sprites<br>      .map(<span class="hljs-function">(<span class="hljs-params">sprite</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^van-/</span>.test(sprite.name)) &#123;<br>          name = <span class="hljs-string">`.<span class="hljs-subst">$&#123;sprite.name&#125;</span>`</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          name = <span class="hljs-string">`.&#123;$spriteName&#125;-<span class="hljs-subst">$&#123;sprite.name&#125;</span>`</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^tab-([\w]+)_a$/</span>.test(sprite.name)) &#123;<br>          name = <span class="hljs-string">&quot;.van-tabbar-item--active &quot;</span> + name.replace(<span class="hljs-string">&quot;_a&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/_a$/</span>.test(sprite.name)) &#123;<br>          name = name.replace(<span class="hljs-string">&quot;_a&quot;</span>, <span class="hljs-string">&quot;.active&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">`</span><br><span class="hljs-string">          <span class="hljs-subst">$&#123;name&#125;</span> &#123;</span><br><span class="hljs-string">            <span class="hljs-subst">$&#123;sprite.name.indexOf(<span class="hljs-string">&quot;van-&quot;</span>) &gt; -<span class="hljs-number">1</span> ? <span class="hljs-string">&quot;@extend .&#123;$spriteName&#125;&quot;</span> : <span class="hljs-string">&quot;&quot;</span>&#125;</span></span><br><span class="hljs-string">            background-position: ptr(-<span class="hljs-subst">$&#123;sprite.x&#125;</span>) ptr(-<span class="hljs-subst">$&#123;sprite.y&#125;</span>);</span><br><span class="hljs-string">            width: ptr(<span class="hljs-subst">$&#123;sprite.width&#125;</span>);</span><br><span class="hljs-string">            height: ptr(<span class="hljs-subst">$&#123;sprite.height&#125;</span>);</span><br><span class="hljs-string">          &#125;</span><br><span class="hljs-string">        `</span>;<br>      &#125;)<br>      .join(<span class="hljs-string">&quot;&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">let</span> mainCSS = <span class="hljs-string">`</span><br><span class="hljs-string">      $spriteName= &quot;<span class="hljs-subst">$&#123;spritesheet.name&#125;</span>&quot;</span><br><span class="hljs-string">      .&#123;$spriteName&#125;&#123;</span><br><span class="hljs-string">          position: relative;</span><br><span class="hljs-string">          display: inline-block;</span><br><span class="hljs-string">          font-style: normal;</span><br><span class="hljs-string">          vertical-align: middle;</span><br><span class="hljs-string">          background-image: url(&quot;<span class="hljs-subst">$&#123;spritesheet.image&#125;</span>&quot;);</span><br><span class="hljs-string">          background-size: ptr(<span class="hljs-subst">$&#123;spritesheet.width&#125;</span>) ptr(<span class="hljs-subst">$&#123;spritesheet.height&#125;</span>);</span><br><span class="hljs-string">      &#125;</span><br><span class="hljs-string">      <span class="hljs-subst">$&#123;spritesCSS&#125;</span></span><br><span class="hljs-string">  `</span>;<br>  <span class="hljs-keyword">return</span> [mainCSS, <span class="hljs-string">&quot;styl&quot;</span>]; <span class="hljs-comment">//返回样式规则文本和文件后缀名</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>  这样就可以通过自由的改变逻辑完成多变的需求啦。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
          <category> WEB开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rem响应式网站适配解决方案</title>
      <link href="202011/web-rem-resolve/"/>
      <url>202011/web-rem-resolve/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/web-rem-resolve/cover.png" class="" width="0" height="0"><h2 id="REM是什么"><a href="#REM是什么" class="headerlink" title="REM是什么"></a>REM是什么</h2><blockquote><p>本文属REM方案的进阶思考，阅读者默认已了解REM方案的原理</p></blockquote><ul><li>搜 <a href="https://www.google.com/search?q=rem+%E6%96%B9%E6%A1%88">Google</a></li><li>搜 <a href="https://www.baidu.com/s?w=rem+%E6%96%B9%E6%A1%88">百度</a></li></ul><h2 id="常见的解决方案"><a href="#常见的解决方案" class="headerlink" title="常见的解决方案"></a>常见的解决方案</h2><ul><li><strong>IDE 插件进行直接转换</strong><ul><li>优点：装好即用</li><li>缺点：不易维护，且大部分情况下无法团队协同，直接修改了源码的数值单位，且一般使用 1rem = 16px 的方案，导致被转换后小数点太多，再次修改时不直观</li></ul></li><li><strong>WebPack Plugin或Loader转换</strong><ul><li>优点：相较于IDE易于团队协作，仅需配置即可直接使用</li><li>缺点：不太支持响应式设置</li></ul></li></ul><h2 id="REM-解决方案"><a href="#REM-解决方案" class="headerlink" title="REM 解决方案"></a>REM 解决方案</h2><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><blockquote><p>以需开发 <em>PC端</em> 和 <em>手机端</em> 的响应式项目为例</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recal</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> docElement = <span class="hljs-built_in">document</span>.documentElement || <span class="hljs-built_in">document</span>.body;<br>    <br>    <span class="hljs-comment">// #region 可根据响应式需求自由调整逻辑</span><br>    <span class="hljs-keyword">let</span> clientWidth = docElement.clientWidth,<br>      designWidth = <span class="hljs-number">1200</span>; <span class="hljs-comment">//PC端设计稿宽度（主内容区域）</span><br><br>    <span class="hljs-keyword">if</span> (clientWidth &lt; <span class="hljs-number">750</span>) &#123; <span class="hljs-comment">// 客户端屏幕宽度小于一定尺寸时</span><br>      designWidth = <span class="hljs-number">640</span>; <span class="hljs-comment">//转为移动端设计稿宽度</span><br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clientWidth &lt; designWidth) &#123;<span class="hljs-comment">// 客户端屏幕宽度小于PC端设计稿时</span><br>      clientWidth -= <span class="hljs-number">80</span> <br>      <span class="hljs-comment">//解决在750~1200左右单独设计的情况，让内容主体与浏览器有空隙</span><br><br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//否则直接应用PC端设计稿宽度</span><br>      clientWidth = designWidth;<br>    &#125;<br>    <span class="hljs-comment">// #region </span><br>    docElement.style.fontSize = (clientWidth / designWidth) * <span class="hljs-number">100</span> + <span class="hljs-string">&quot;px&quot;</span>;<br>  &#125;<br>  <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;resize&quot;</span>, recal);<br>  recal();<br>&#125;)();<br></code></pre></td></tr></table></figure><p><strong>将js代码放在 <code>&lt;head&gt;</code> 内，且不依赖任何插件以保证他最早被执行。</strong></p><p>使用css预处理器编写函数(我这边用的是stylus)</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs styl"><span class="hljs-function"><span class="hljs-title">ptr</span><span class="hljs-params">(px)</span></span>&#123;<br>  return unit((px / 100), &#x27;rem&#x27;);<br>&#125;<br><br>body&#123;<br>  <span class="hljs-attribute">font-size</span>: ptr(<span class="hljs-number">12</span>)<br>&#125;<br><br><span class="hljs-comment">// 使用方法</span><br>.container&#123;<br>  <span class="hljs-attribute">width</span>: ptr(<span class="hljs-number">1200</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h3><p>  通过响应式设计稿尺寸不一的情况下，通过 <code>窗口宽度</code> 变化时判断选用不同端的 <code>设计稿宽度</code> 运算，辅以 <code>css3</code> 的 <code>media</code> 即可完美复现响应式下的设计啦</p><p>  通过 css预处理器的function功能，对单位直接运算，这样就可以愉快的直接将设计稿取到的值直接写入到 <code>ptr(value)</code> 中完成复现。</p><blockquote><p>记一次使用 css预处理 ptr函数 的奇妙经历：当你因某些原因更换方案时，可直接重写 ptr函数 的 运算方式 达到一步到位的维护效果</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
          <category> WEB开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 解决方案 </tag>
            
            <tag> 响应式 </tag>
            
            <tag> 适配 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
