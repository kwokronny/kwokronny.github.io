<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>stylus-shortcut 速建主题</title>
      <link href="202012/stylus-shortcut/"/>
      <url>202012/stylus-shortcut/</url>
      
        <content type="html"><![CDATA[<img src="/202012/stylus-shortcut/cover.png" width="0" height="0"><blockquote><a href="/202012/css-pre-handler/" title="CSS预处理哪家强？">CSS预处理哪家强？</a></blockquote><p>stylus-shortcut 可以加速编写 CSS，通过 stylus 中 mixin 的功能，将样式常用组合合并汇以简单一句，减少代码的编写量；并通过 stylus 循环将常用主题变量生成常用的样式规则，可快捷使用。</p><ul><li><strong><a href="https://kwokronny.top/stylus-shortcut-document/">说明文档</a></strong></li><li><strong><a href="https://github.com/hiyoz/stylus-shortcut" target="_blank" rel="noopener">项目仓库</a></strong></li></ul><h2 id="开发意图"><a href="#开发意图" class="headerlink" title="开发意图"></a>开发意图</h2><p>编写这个项目最初的目的是在开发一 SAAS 平台时，我已采用 iviewUI 的基础上进行开发，并通过自定义主题覆盖了部分样式及颜色变量后。常常需要在部分元素上为元素命名后仅仅为其加一项间距属性或文本颜色等简单的样式。来回切换样式文件与 DOM 文件，及为不重要的小元素命名，多而烦；或许这也是为什么 Bootstrap 可以一下成为大家热爱的库吧。</p><p>所以我简单通过 stylus 的循环按设计规范中常用的间距生成了多个间距样式及颜色样式，真的非常的方便与快落；事实证明频繁的切换文件是容易忘记自己需要做什么的。<br>再之后，为一些复杂的设计编写样式时，常常在写完 width 时基本下一句可能就是 height，嗒嗒嗒下来，写了许多行，但常常这些伴随着规律，定位时会写 left,top、宽高写完时可能还会再设置个圆角等，写了几年前端后早已厌烦了长长的样式规则。<br>所以我通过 stylus 的 mixin 功能，将编写 CSS 时常用的规律汇成一句，小小的功能，也可以提升大大的效率。<br>编写文档时，也常问自己项目如此的小，是否需要变成一个库呢？我找到了答案，小而简就是这个项目的初心，他解决的是开发中常常忽视的小烦恼，整理出规律增加编写效率也是这个小项目最重要的核心<br>如果你也同我一样存在这些厌烦，不妨试试这个库哟~</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>通过 stylus 的特性整理开发的一套加速样式编写的解决方案</li><li>可快速将设计中常用的规范转化为变量生成常用的样式</li><li>命名规则应用尊循 BEM</li><li>小而美，只解决常见但小的麻烦</li></ul><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">@import "your-custom-variable-file.styl" //引入自定义变量<br>// 同时引入 shortcut.styl mixin.styl<br>@import "~@hiyoz/stylus-shortcut"<br>// or 单独引入 shortcut.styl<br>@import "~@hiyoz/stylus-shortcut/src/shortcut.styl<br>// or 单独引入 mixin.styl<br>@import "~@hiyoz/stylus-shortcut/src/mixin.styl<br></code></pre></td></tr></table></figure><blockquote><p>变量与mixin需要在多文件下自动引用可通过stylus-loader<br>如 vue-cli@3 配置示例，在 stylus-loader 中配置 import 全局引入</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//vue.config.js</span><br>modules.export=&#123;<br>  ...<br>  css: &#123;<br>    <span class="hljs-comment">// 配置css模块</span><br>    <span class="hljs-attr">loaderOptions</span>: &#123;<br>      <span class="hljs-comment">// 向预处理器 Loader 传递配置选项</span><br>      <span class="hljs-attr">stylus</span>: &#123;<br>        <span class="hljs-attr">import</span>: [<br>          <span class="hljs-string">"your-custom-variable-file.styl"</span>,<br>          <span class="hljs-string">"@hiyoz/stylus-shortcut/src/mixin.styl"</span><br>        ]<br>      &#125;<br>    &#125;<br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs variable.styl">yoz_color = &#123;<br>  primary: #1890ff,<br>  link: #1890ff,<br>  success: #52c41a,<br>  warning: #faad14,<br>  error: #f5222d<br>&#125;;<br>yoz_spacing ?= &#123;<br>  &apos;5&apos;: 5px,<br>  &apos;10&apos;: 10px,<br>  &apos;20&apos;: 20px,<br>  &apos;30&apos;: 30px<br>&#125;;<br>...<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"flex-h"</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text-c_primary"</span>&gt;</span>文本颜色primary<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--文本颜色为变量值primary--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box bg-c_primary spac-ml_20"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--背景颜色为primary--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box bg-c_primary spac-mh_20"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--水平外间距--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box bg-c_primary spac-p_20"</span>&gt;</span>内间距<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--四边内间距--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
          <category> WEB开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stylus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS预处理哪家强？</title>
      <link href="202012/css-pre-handler/"/>
      <url>202012/css-pre-handler/</url>
      
        <content type="html"><![CDATA[<img src="/202012/css-pre-handler/cover.png" width="0" height="0"><h1 id="不想再回到的CSS时代"><a href="#不想再回到的CSS时代" class="headerlink" title="不想再回到的CSS时代"></a>不想再回到的CSS时代</h1><p>刚学前端时，各预处理软件还没出现，犹记得当时写的最好的 CSS格式是这样</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.panel</span>&#123; <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>; <span class="hljs-attribute">height</span>:<span class="hljs-number">800px</span>; <span class="hljs-attribute">margin</span>: <span class="hljs-number">30px</span> &#125;<br><span class="hljs-selector-class">.panel</span> <span class="hljs-selector-class">.panel-title</span>&#123; <span class="hljs-attribute">font-size</span>: <span class="hljs-number">18px</span>; <span class="hljs-attribute">font-weight</span>:bold; &#125;<br></code></pre></td></tr></table></figure><p>在当时CSS不支持嵌套的时代，这样的CSS规则简单易找易看懂，加上浏览器商逐鹿的时间段，被样式<code>-webkit-</code>、<code>-moz-</code>等前缀烦死。</p><h1 id="各大预处理器的出现"><a href="#各大预处理器的出现" class="headerlink" title="各大预处理器的出现"></a>各大预处理器的出现</h1><p>为了解决日益复杂的交互需求，及更规范的前端工程化，伟大的先驱们开发了许许多多加速工作效率解决方案。</p><p>各大CSS预处理器出现后，我基本每款都在项目中实践应用过，就说说他们的优劣势水水文吧。</p><blockquote><p>产品的优劣很多时候是针对需求而言的，所以以下优劣仅以是针对我个人而言，供大家参考。</p></blockquote><h2 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h2><p>个人最开始使用的预处理语言，当时的 webpack 在我身边刚开始普及，大部分还主要是gulp、grunt的天下，我的前端视界也还未被打开，前后端处于半分离的模式，由后端渲染页面，前端部分交互由接口完成。开始接触到Less的我觉得方便极了，拥有常见的变量，函数，导入，混合，逻辑运算、嵌套等功能，这些功能极大的减少了CSS的编写量，算是非常轻量好上手的预处理工具了。</p><h2 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h2><p>接触Less的同时也了解到有Sass这个更强大的预处理器。但个人对webpack及前端项目工程化还不太熟悉的我先选择了less做为入门先，有了基本的前端工程化思维后才正式开始使用Sass开发项目；Sass给我的感觉是在逻辑运算上，自定义函数等多方面更优于Less，但语法复杂度确实相较于Less难上手许多，语法也更为严谨，但对于个人对CSS预处理器的期望需求仅仅是完成变量，循环，模块化CSS，自定义函数等功能的我来说。Sass过于臃肿，最大烦恼莫过于npm安装时，node-sass在国内环境下无法正常安装，经常出现超时等无法安装的问题，虽说找到过解决方案，但实在是令人难受，CSS作为WEB界面配置的其中一环，使用一门如此麻烦严谨的语言，实在是有些难以接受。</p><h2 id="Stylus"><a href="#Stylus" class="headerlink" title="Stylus"></a>Stylus</h2><p>一次机缘巧合下，接触到了一个项目，项目中运用的CSS预处理语言独树一帜，无花括号，无分号等；其实早前了解时有知道过这个stylus，但当时主要展示的是无花括号及分号的写法，个人到现在其实都不太相信，因为没有界限及通过制表符完成嵌套等语句功能，实在时太容易出问题了。对于文件编码及换行符的未深入了解的鸵鸟人来说。这种不确定性我还是想避免的。事实证明，在刚开始接触这种写法时，还是挺爽的，但可能mac上打的一个奇怪的空格，或换行符等问题，会让你摸不着头脑的找不到出问题的位置。</p><blockquote><p>但这个语言其实亦支持使用花括号及分号，只需要配置格式化工具即可，这样就再也不会有那种因编码等导致的令人头大的问题了</p></blockquote><p><strong>VS Code中的格式化插件是：<a href="https://marketplace.visualstudio.com/items?itemName=thisismanta.stylus-supremacy" target="_blank" rel="noopener">Manta’s Stylus Supremacy</a></strong></p><p>至此，这款stylus便是我最爱用的一款预处理工具了，如less般好上手，拥有sass般强大的功能，逻辑循环等语法简单且像js，支持集合变量等，让人爱不释手。下面是我最近有整合的stylus-shortcut库中部分代码，可以通过变量快速完成一套bootstrap式的CSS规则，快速应用。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs stylus">.flex &#123;<br>$flex_direction = &#123;<br>h: row,<br>h_rtl: row-reverse,<br>v: column,<br>v_rtl: column-reverse<br>&#125;;<br><br>for $name, $value in $flex_direction &#123;<br>&amp;-&#123;$name&#125; &#123;<br>display: flex;<br>flex-direction: $value;<br>&#125;<br>&#125;<br>&#125;<br><br>yoz_text_align = &#123;<br>  l: left,<br>  r: right,<br>  c: center,<br>  j: justify<br>&#125;;<br><br>for $name, $value in yoz_text_align &#123;<br>  .text-a_&#123;$name&#125; &#123;<br>    text-align: $value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> 杂文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KeePassXC 简易教程</title>
      <link href="202011/keepassxc-tutorials/"/>
      <url>202011/keepassxc-tutorials/</url>
      
        <content type="html"><![CDATA[<img src="/202011/keepassxc-tutorials/cover.png" width="0" height="0"><blockquote><p>前面我写了一篇安利这款应用文章，接下来也就给大家大概的介绍下这款软件的使用教程 </p><a href="/202011/recommend-keepass/" title="安利一款免费好用的开源密码管理软件 - KeePassXC">安利一款免费好用的开源密码管理软件 - KeePassXC</a></blockquote><h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2><ol><li><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p> 再放置个传送门 <a href="https://keepassxc.org/" target="_blank" rel="noopener">传送门</a><br> 根据自己的系统下载匹配的<code>KeePassXC</code>软件,</p> <img src="/202011/keepassxc-tutorials/download_page.png"><p> 下载后按系统常用方式安装软件即可。</p></li><li><h3 id="生成密码库文件"><a href="#生成密码库文件" class="headerlink" title="生成密码库文件"></a>生成密码库文件</h3><blockquote><p>已用KeePass或其他第三方基于KeePass的软件生成的密码文件，可跳过此步骤，直接打开食用<br> 安装完成后并打开后，如下图所示（软件语言多种，默认跟随系统语言）</p></blockquote><ol><li><p>点击 <code>新建数据库/Create new database</code> 弹出新建窗口</p></li><li><p>填写数据库名称，点击下一步。</p><img src="/202011/keepassxc-tutorials/create_lib.png"></li><li><p>加密设置，此步骤可直接下一步，亦可详细了解下，毕竟我的隐私不涉及PY交易，所以加密复杂度正常就好。（后面想改也可以改）</p><img src="/202011/keepassxc-tutorials/setting_encrypt.png"></li><li><p>密码设置，输入你的主密码，及再次输入后，确认并保存到存储的位置就完成啦。</p><blockquote><p>数据库的钥匙，唯一要记住的密码，每次数据库因限定时间未使用时或锁屏离开后锁定时，都需要输入这个密码解锁使用存储的密码。（主密码最好定期更换），有条件的亦可增加硬件设备使用，增强安全性。</p></blockquote><img src="/202011/keepassxc-tutorials/setting_main_password.png"></li><li><p>__最后一个大问题__：密码的存放</p><p>因需要多平台使用，密码库的同步尤为重要；需要借助云盘完成。（当然，亦可以自架服务存储并使用）</p><p>推荐云盘：<code>oneDriver</code></p><p>那同步的位置好了后，接下来就只用把生成好的数据库文件放到云盘就OK啦。</p><img src="/202011/keepassxc-tutorials/icloud.png"></li></ol></li><li><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li><p>查看设置项，设置项可根据自己的习惯配置，我就不一一说明了。</p><blockquote><p>其中需要注意的是 常规-&gt;基础设置-&gt;用户界面 记得勾选<code>最小化而不是退出应用程序</code>，保持程序启动。</p></blockquote><img src="/202011/keepassxc-tutorials/base_setting.png"></li><li><p>下载浏览器扩展并配置连接数据库</p><img src="/202011/keepassxc-tutorials/setting_browser.png"><p>如上图按需配置，并按所用的浏览器下载对应的扩展。进入浏览器扩展进行配置绑定即可</p><img src="/202011/keepassxc-tutorials/bind_browser.jpg"></li><li><p>当我们打开浏览器登陆时，KeePassXC会通过匹配链接后询问是否授权信息，确认后，当只有一个密码时就会直接自动输入到输入框了，该平台有多个账号时亦可点击输入框后切换。</p><img src="/202011/keepassxc-tutorials/browser_request.png"><img src="/202011/keepassxc-tutorials/browser_input.png"></li></ol><p>还有更多的细节等待你的摸索啦~</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安利一款免费好用的开源密码管理软件 - KeePassXC</title>
      <link href="202011/recommend-keepass/"/>
      <url>202011/recommend-keepass/</url>
      
        <content type="html"><![CDATA[<img src="/202011/recommend-keepass/cover.png" width="0" height="0"><h2 id="用过的密码管理软件"><a href="#用过的密码管理软件" class="headerlink" title="用过的密码管理软件"></a>用过的密码管理软件</h2><p>推荐前先介绍自己在密码管理上经历过的历程，无兴趣可直接跳过这一段</p><ol><li><h3 id="级别密码制"><a href="#级别密码制" class="headerlink" title="级别密码制"></a>级别密码制</h3><p>统一三个级别的密码，分为：无隐私风险，轻隐私风险，重度隐私风险的密码，密码复杂度按级别升高。方便，只用记三个密码即可尽可能的保护自己的隐私和方便自己的记忆。</p></li><li><h3 id="lastpass"><a href="#lastpass" class="headerlink" title="lastpass"></a>lastpass</h3><p><code>超能小紫</code>最早推荐我用的密码管理的CHORME扩展，后来也因为曝出过相关的密码泄漏新闻，所以就试着找个安全些的。</p></li><li><h3 id="1Password"><a href="#1Password" class="headerlink" title="1Password"></a>1Password</h3><p>同样是<code>超能小紫</code>给我安利的，刚好试着免费试用1年，试用了几个月，个人在使用上感觉在交互还是不太喜爱，各平台的操作相对不统一，密码生成、删除，修改等操作上有些麻烦，特别是我在新平台注册活登陆时不会自动收集我的信息询问我是否存储，不知是不是我没配置好；这样想想订阅费用还是让我稍稍心痛的。</p></li></ol><h2 id="正式安利-KeePass"><a href="#正式安利-KeePass" class="headerlink" title="正式安利 - KeePass"></a>正式安利 - KeePass</h2><p>KeePass起初真只是抱着试试的心态，毕竟大概如果有了解的话，KeePass的相关官网包括网上许多的使用文档中的软件截图，界面风格跟2000年基本无异了；我主要电脑是MacBook的，一开始还真没打算用这套全平台解决方案，想着再找找，但突然认真看了下网站，发现开源的项目，都有着伟大的开源精神的程序员圈子，一个平台出现了三四种基于keepass的第三方版本及各种原生插件。</p><img src="/202011/recommend-keepass/main_big.png"><p>官方版本KeePass</p><ol><li><h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><p>开始试着把以前的密码数据导出后，开始试着转移密码到这个新的解决方案的载体时，官方提供的各平台版本，其实在交互上及实用性上都确认不及<code>1Password</code>所带出的基本功能，各平台间交互差异大，且直接无浏览器扩展的支持，有的也只是已从谷歌官方应用扩展商店下架后，博主间传出的离线版本了；所以还真有点想放弃，老实交钱用回<code>1Password</code>了。</p><blockquote><p>就在我准备放弃前，多搜索了一次。我拥抱了开源</p></blockquote></li><li><h3 id="发现宝藏"><a href="#发现宝藏" class="headerlink" title="发现宝藏"></a>发现宝藏</h3><p>在一次无意的搜索中，我发现了这款基于<code>KeePass</code>开发的第三方全平台支持的软件版本</p><a target="_blank" href="https://keepassxc.org/"><center><img src="/202011/recommend-keepass/keepassxc-logo.svg" width="100"></center><center style="color:#30782f">KeePassXC</center></a><p>一起先看看的截图</p><img src="/202011/recommend-keepass/welcome_screen.png"><img src="/202011/recommend-keepass/database_view.png"></li></ol><blockquote><a href="/202011/keepassxc-tutorials/" title="KeePassXC 简易教程">KeePassXC 简易教程</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雪碧图命令行工具开发完结撒花</title>
      <link href="202011/sprites-cli-develop/"/>
      <url>202011/sprites-cli-develop/</url>
      
        <content type="html"><![CDATA[<img src="/202011/sprites-cli-develop/cover.png" width="0" height="0"><h2 id="小图的烦恼"><a href="#小图的烦恼" class="headerlink" title="小图的烦恼"></a>小图的烦恼</h2><p>项目中经常有不可避免的出现小图标，雪碧图依然是很多团队的选择，网上也有了各种各样的雪碧图插件或方案等。但大多数仅仅实现了简易的拼图及规则生成，我在项目中常常遇到两个小图需要在用户交互时切换等甚至更为复杂的需求；终于在百忙<del>懒癌绝症</del>之中搞了一个生成雪碧图的命令行小工具，望大家参考指教。</p><p><a href="https://github.com/hiyoz/sprites-cli" target="_blank" rel="noopener">传送门</a></p><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><ul><li><h3 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h3></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install @hiyoz/sprite-cli -g<br><br>sprites-cli [options]<br><br>通过命令对指定目录下的所有结尾 -sprite 结束的雪碧图文件夹，生成雪碧图到指定的生成目录，并生成雪碧图的对应样式文件。支持不同文件夹自定义CSS样式<br><br>Options:<br>  -s, --scope [value]  [必填]设定范围目录，范围目录下所有结尾 -sprite 结束的雪碧图文件夹<br>  -r, --rule [value]   生成sheet规则版本: css less scss stylus，默认使用css若 优先使用雪碧图文件夹下有 template.js 生成规则脚本<br>  -d, --dist [value]   生成目录[范围目录的相对路径]，默认 <span class="hljs-string">"./"</span><br></code></pre></td></tr></table></figure><ul><li><h3 id="基础使用示例"><a href="#基础使用示例" class="headerlink" title="基础使用示例"></a>基础使用示例</h3><p>  <code>demo</code>目录下<code>galaxy-sprite</code>存储了等待合成的雪碧图原料。希望生成stylus的CSS规则文件</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sprites-cli -s demo -r stylus<br></code></pre></td></tr></table></figure><p>  通过命令即可在demo目录下生成galaxy-sprite.styl与galaxy-sprite.png文件。</p></li><li><h3 id="自定义样式生成"><a href="#自定义样式生成" class="headerlink" title="自定义样式生成"></a>自定义样式生成</h3><p>  部分雪碧图在使用时希望支持一定的交互效果，如：某图标在移过去时变换成另一个图标时；即可通过自定义样式生成的方案，在自定义生成符合需求的CSS规则。</p><p>  仅需将在 相应的雪碧图文件夹内 如：<code>[name]-sprite</code>文件夹下，创建<code>template.js</code>文件，代码如下：</p><blockquote><p>当雪碧图文件夹下存在<code>template.js</code>时，该雪碧图文件夹的CSS规则生成仅以此为唯一的生成规则</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">spritesheet</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> spritesCSS = <span class="hljs-string">``</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(spritesheet.sprites)) &#123;<br>    spritesCSS = spritesheet.sprites<br>      .map(<span class="hljs-function">(<span class="hljs-params">sprite</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> name = <span class="hljs-string">""</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^van-/</span>.test(sprite.name)) &#123;<br>          name = <span class="hljs-string">`.<span class="hljs-subst">$&#123;sprite.name&#125;</span>`</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          name = <span class="hljs-string">`.&#123;$spriteName&#125;-<span class="hljs-subst">$&#123;sprite.name&#125;</span>`</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^tab-([\w]+)_a$/</span>.test(sprite.name)) &#123;<br>          name = <span class="hljs-string">".van-tabbar-item--active "</span> + name.replace(<span class="hljs-string">"_a"</span>, <span class="hljs-string">""</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/_a$/</span>.test(sprite.name)) &#123;<br>          name = name.replace(<span class="hljs-string">"_a"</span>, <span class="hljs-string">".active"</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">`<br>          <span class="hljs-subst">$&#123;name&#125;</span> &#123;<br>            <span class="hljs-subst">$&#123;sprite.name.indexOf(<span class="hljs-string">"van-"</span>) &gt; <span class="hljs-number">-1</span> ? <span class="hljs-string">"@extend .&#123;$spriteName&#125;"</span> : <span class="hljs-string">""</span>&#125;</span><br>            background-position: ptr(-<span class="hljs-subst">$&#123;sprite.x&#125;</span>) ptr(-<span class="hljs-subst">$&#123;sprite.y&#125;</span>);<br>            width: ptr(<span class="hljs-subst">$&#123;sprite.width&#125;</span>);<br>            height: ptr(<span class="hljs-subst">$&#123;sprite.height&#125;</span>);<br>          &#125;<br>        `</span>;<br>      &#125;)<br>      .join(<span class="hljs-string">""</span>);<br>  &#125;<br>  <span class="hljs-keyword">let</span> mainCSS = <span class="hljs-string">`<br>      $spriteName= "<span class="hljs-subst">$&#123;spritesheet.name&#125;</span>"<br>      .&#123;$spriteName&#125;&#123;<br>          position: relative;<br>          display: inline-block;<br>          font-style: normal;<br>          vertical-align: middle;<br>          background-image: url("<span class="hljs-subst">$&#123;spritesheet.image&#125;</span>");<br>          background-size: ptr(<span class="hljs-subst">$&#123;spritesheet.width&#125;</span>) ptr(<span class="hljs-subst">$&#123;spritesheet.height&#125;</span>);<br>      &#125;<br>      <span class="hljs-subst">$&#123;spritesCSS&#125;</span><br>  `</span>;<br>  <span class="hljs-keyword">return</span> [mainCSS, <span class="hljs-string">"styl"</span>]; <span class="hljs-comment">//返回样式规则文本和文件后缀名</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>  这样就可以通过自由的改变逻辑完成多变的需求啦。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
          <category> WEB开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rem响应式网站适配解决方案</title>
      <link href="202011/web-rem-resolve/"/>
      <url>202011/web-rem-resolve/</url>
      
        <content type="html"><![CDATA[<img src="/202011/web-rem-resolve/cover.png" width="0" height="0"><h2 id="REM是什么"><a href="#REM是什么" class="headerlink" title="REM是什么"></a>REM是什么</h2><blockquote><p>本文属REM方案的进阶思考，阅读者默认已了解REM方案的原理</p></blockquote><ul><li>搜 <a href="https://www.google.com/search?q=rem+%E6%96%B9%E6%A1%88" target="_blank" rel="noopener">Google</a></li><li>搜 <a href="https://www.baidu.com/s?w=rem+%E6%96%B9%E6%A1%88" target="_blank" rel="noopener">百度</a></li></ul><h2 id="常见的解决方案"><a href="#常见的解决方案" class="headerlink" title="常见的解决方案"></a>常见的解决方案</h2><ul><li><strong>IDE 插件进行直接转换</strong><ul><li>优点：装好即用</li><li>缺点：不易维护，且大部分情况下无法团队协同，直接修改了源码的数值单位，且一般使用 1rem = 16px 的方案，导致被转换后小数点太多，再次修改时不直观</li></ul></li><li><strong>WebPack Plugin或Loader转换</strong><ul><li>优点：相较于IDE易于团队协作，仅需配置即可直接使用</li><li>缺点：不太支持响应式设置</li></ul></li></ul><h2 id="REM-解决方案"><a href="#REM-解决方案" class="headerlink" title="REM 解决方案"></a>REM 解决方案</h2><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><blockquote><p>以需开发 <em>PC端</em> 和 <em>手机端</em> 的响应式项目为例</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recal</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> docElement = <span class="hljs-built_in">document</span>.documentElement || <span class="hljs-built_in">document</span>.body;<br>    <br>    <span class="hljs-comment">// #region 可根据响应式需求自由调整逻辑</span><br>    <span class="hljs-keyword">let</span> clientWidth = docElement.clientWidth,<br>      designWidth = <span class="hljs-number">1200</span>; <span class="hljs-comment">//PC端设计稿宽度（主内容区域）</span><br><br>    <span class="hljs-keyword">if</span> (clientWidth &lt; <span class="hljs-number">750</span>) &#123; <span class="hljs-comment">// 客户端屏幕宽度小于一定尺寸时</span><br>      designWidth = <span class="hljs-number">640</span>; <span class="hljs-comment">//转为移动端设计稿宽度</span><br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clientWidth &lt; designWidth) &#123;<span class="hljs-comment">// 客户端屏幕宽度小于PC端设计稿时</span><br>      clientWidth -= <span class="hljs-number">80</span> <br>      <span class="hljs-comment">//解决在750~1200左右单独设计的情况，让内容主体与浏览器有空隙</span><br><br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//否则直接应用PC端设计稿宽度</span><br>      clientWidth = designWidth;<br>    &#125;<br>    <span class="hljs-comment">// #region </span><br>    docElement.style.fontSize = (clientWidth / designWidth) * <span class="hljs-number">100</span> + <span class="hljs-string">"px"</span>;<br>  &#125;<br>  <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">"resize"</span>, recal);<br>  recal();<br>&#125;)();<br></code></pre></td></tr></table></figure><p><strong>将js代码放在 <code>&lt;head&gt;</code> 内，且不依赖任何插件以保证他最早被执行。</strong></p><p>使用css预处理器编写函数(我这边用的是stylus)</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs styl">ptr(px)&#123;<br>  return unit((px / 100), 'rem');<br>&#125;<br><br>body&#123;<br>  font-size: ptr(12)<br>&#125;<br><br>// 使用方法<br>.container&#123;<br>  width: ptr(1200);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h3><p>  通过响应式设计稿尺寸不一的情况下，通过 <code>窗口宽度</code> 变化时判断选用不同端的 <code>设计稿宽度</code> 运算，辅以 <code>css3</code> 的 <code>media</code> 即可完美复现响应式下的设计啦</p><p>  通过 css预处理器的function功能，对单位直接运算，这样就可以愉快的直接将设计稿取到的值直接写入到 <code>ptr(value)</code> 中完成复现。</p><blockquote><p>记一次使用 css预处理 ptr函数 的奇妙经历：当你因某些原因更换方案时，可直接重写 ptr函数 的 运算方式 达到一步到位的维护效果</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
          <category> WEB开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
