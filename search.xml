<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>读《图解HTTP》第三、四章阅读笔记</title>
      <link href="202102/read-book-diagram-http-2/"/>
      <url>202102/read-book-diagram-http-2/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202102/read-book-diagram-http-2/cover.png" class="" width="0" height="0"><h1 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h1><ul><li><h2 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h2><p>下图为请求报文及响应报文结构</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202102/read-book-diagram-http-2/http_message_struc.jpg" class=""><table><thead><tr><th align="left">组成</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">请求行</td><td align="left"><code>[请求方法] [URI] [HTTP版本]</code> 格式，用于请求时</td></tr><tr><td align="left">状态行</td><td align="left"><code>[HTTP版本] [HTTP状态码] [原因短语]</code> 格式，告知响应的状态</td></tr><tr><td align="left">首部字段</td><td align="left">每个字段以 <code>[字段名]:[值]</code> 为一行格式写入，一般首部分为：通用首部、请求首部、响应首部和实体首部</td></tr><tr><td align="left">其他</td><td align="left">可能包含 HTTP 的 RFC 里未定义的首部，如 Cookie 等</td></tr></tbody></table><ul><li><h3 id="常用首部字段"><a href="#常用首部字段" class="headerlink" title="常用首部字段"></a>常用首部字段</h3><ul><li>通用首部字段（请求报文与响应报文都会使用的首部字段）<br>Date：创建报文时间<br>Connection：连接的管理<br>Cache-Control：缓存的控制<br>Transfer-Encoding：报文主体的传输编码方式</li><li>请求首部字段（请求报文会使用的首部字段）<br>Host：请求资源所在服务器<br>Accept：可处理的媒体类型<br>Accept-Charset：可接收的字符集<br>Accept-Encoding：可接受的内容编码<br>Accept-Language：可接受的自然语言</li><li>响应首部字段（响应报文会使用的首部字段）<br>Accept-Ranges：可接受的字节范围<br>Location：令客户端重新定向到的 URI<br>Server：HTTP 服务器的安装信息</li><li>实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）<br>Allow：资源可支持的 HTTP 方法<br>Content-Type：实体主类的类型<br>Content-Encoding：实体主体适用的编码方式<br>Content-Language：实体主体的自然语言<br>Content-Length：实体主体的的字节数<br>Content-Range：实体主体的位置范围，一般用于发出部分请求时使用</li></ul></li></ul></li><li><h2 id="编码传输速率"><a href="#编码传输速率" class="headerlink" title="编码传输速率"></a>编码传输速率</h2><ul><li><p><strong>报文主体与实体主体差异</strong></p><ul><li><p><strong>报文(message)</strong><br>是 HTTP 通信中的基本单位，由 8 位组字节流组成、 通过 HTTP 通信传输</p></li><li><p><strong>实体(entity)</strong><br>为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成</p></li></ul><p>通常，报文主体等于实体主体。只有当传输中进行编码时，实体主体的内容发生变化，导致它和报文主体产生差展示</p></li><li><p><strong>常用压缩传输的内容编码</strong></p><ul><li>gzip (GUN zip)</li><li>compress (UNIX 系统的标准压缩)</li><li>deflate (zlib)</li><li>identity (不进行编码)</li></ul></li><li><p><strong>分割发送的分块传输编码（Chunked Transfer Coding）</strong><br>在 HTTP 通信时，请求的编码实体资源尚未全部传输完成前，浏览器无法显示请求的页面。在传输大容量数据时，通过将数据分割成多块，让浏览器逐步显示页面。<br>将实体主体分块，将每一块用<code>十六进制</code>标记块的大小，最后一块使用<code>0(CR+LF)</code>标记</p></li></ul></li><li><h2 id="发送多种数据的多部分对象集合"><a href="#发送多种数据的多部分对象集合" class="headerlink" title="发送多种数据的多部分对象集合"></a>发送多种数据的多部分对象集合</h2><p>HTTP 协议中采用了与 MIME（Multipurpose Internet Mail Extensions) 同样的多部分对象集合，发送一份报文主体内可含有多类型实体。</p><ul><li><h3 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a>multipart/form-data</h3><p>Web 表单文件上传时使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">Content-Type: multipart&#x2F;form-data;boundary&#x3D;AaB03x<br><br>--AaB03x<br>Content-Dispostion: form-data; name&#x3D;&quot;field1&quot;<br><br>JoeBlow<br>--AaB03x<br>Content-Dispostion: form-data; name&#x3D;&quot;pics&quot;; filename&#x3D;&quot;file1.txt&quot;<br>Content-Type: text&#x2F;plain<br><br>...(file1.txt的数据)...<br>--AaB03x--<br></code></pre></td></tr></table></figure></li><li><h3 id="multipart-byteranges"><a href="#multipart-byteranges" class="headerlink" title="multipart/byteranges"></a>multipart/byteranges</h3><p>状态码 206（部分内容）响应报文包含了多个范围的内容时使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">HTTP&#x2F;1.1 206 Partial Content<br>Date: Fri,13 Jul 2012 02:45:26 GMT<br>Last-Modified: Fri,13 Jul 2012 02:45:26 GMT<br>Content-Type: multipart&#x2F;byteranges; boundary&#x3D;THIS_STRING_SEPARATES<br><br>--THIS_STRING_SEPARATES<br>Content-Type: application&#x2F;pdf<br>Content-Range: bytes 500-999&#x2F;8000<br><br>--THIS_STRING_SEPARATES<br>Content-Type: application&#x2F;pdf<br>Content-Range: bytes 7000-7999&#x2F;8000<br><br>--THIS_STRING_SEPARATES--<br></code></pre></td></tr></table></figure><p>使用 <code>boundary</code> 字符串划分多部分对象集合指明的各类实体。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plain">Content-Type: multipart&#x2F;form-data; boundary&#x3D;[多部分名称字符]<br><br>--[多部分名称字符]<br>实体首部字段1<br><br>实体数据1<br><br>--[多部分名称字符]<br>实体首部字段2<br><br>实体数据2<br><br>...<br><br>--[多部分名称字符]--<br></code></pre></td></tr></table></figure></li></ul></li><li><h2 id="获取部分内容范围请求"><a href="#获取部分内容范围请求" class="headerlink" title="获取部分内容范围请求"></a>获取部分内容范围请求</h2><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202102/read-book-diagram-http-2/http_range_byte.jpg" class=""><ul><li><h3 id="byte-指定形式"><a href="#byte-指定形式" class="headerlink" title="byte 指定形式"></a>byte 指定形式</h3><ul><li>范围<br><code>Range: bytes=5001-10000</code></li><li>由指定字节之后<br><code>Range: bytes=5001-</code></li><li>由指定字节之前<br><code>Range: bytes=-5001</code></li><li>多重范围<br><code>Range: bytes=-3000,5000-7000</code></li></ul></li></ul></li><li><h2 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h2><p>内容协商机制指客户端和服务端就响应资源交涉，为客户端提供最合适的资源，判断基准以语言、字符集、编码方式。</p><ul><li>服务端驱动协商<br>以请求首部字段参考，在服务端自动处理。但对用户来说，以浏览器发送的信息作为判定依据，不一定能筛出最优内容</li><li>客户端驱动协商<br>用户从浏览器显示的可选项列表手动选择，亦可利用 Javascript 脚本在页面上自动选择，如：按 OS 类型或浏览器类型切换 PC 版页面或手机版页面</li><li>透明协商<br>服务商与客户端各自进行内容协商的方法</li></ul></li></ul><h1 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h1><table><thead><tr><th align="left">状态码</th><th align="left">类别</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1XX</td><td align="left">Informational (信息性状态码))</td><td align="left">接收的请求正在处理</td></tr><tr><td align="left">2XX</td><td align="left">Success (成功状态码)</td><td align="left">请求正常处理完毕</td></tr><tr><td align="left">3XX</td><td align="left">Redirection (重定向状态码)</td><td align="left">需要进行附加操作以完成请求</td></tr><tr><td align="left">4XX</td><td align="left">Client Error (客户端错误状态码)</td><td align="left">服务器无法处理请求</td></tr><tr><td align="left">5XX</td><td align="left">Server Error (服务器端错误状态码)</td><td align="left">服务器处理请求错误</td></tr></tbody></table><ul><li><h2 id="2XX-成功状态码-Success"><a href="#2XX-成功状态码-Success" class="headerlink" title="2XX 成功状态码 Success"></a>2XX 成功状态码 Success</h2><ul><li>200 OK<br>  请求已成功处理</li><li>204 No Content<br>  无资源</li><li>206 Partial Content<br>  接受范围请求，并返回了指定范围部分的实体内容</li></ul></li><li><h2 id="3XX-重定向-Redirection"><a href="#3XX-重定向-Redirection" class="headerlink" title="3XX 重定向 Redirection"></a>3XX 重定向 Redirection</h2><ul><li>301 Moved Permanently<br>  永久性重定向</li><li>302 Found<br>  临时性重定向</li><li>303 See Other<br>  看下其他URI，如：<br>  用POST方法访问服务端，执行后服务端返回希望客户端以GET方法重定向到另一个URI时。</li><li>304 Not Modified<br>  已找到资源，但不符合请求条件</li><li>307 Temporary Redirect<br>  临时性重定向，与302 Found有相同含义，区别在于307会遵照浏览器标准。</li></ul></li><li><h2 id="4XX-客户端错误-Client-Error"><a href="#4XX-客户端错误-Client-Error" class="headerlink" title="4XX 客户端错误 Client Error"></a>4XX 客户端错误 Client Error</h2><ul><li>400 Bad Request<br>  请求报文有错误</li><li>401 Unauthorized<br>  请求需要通过HTTP认证（BASIC认证、DIGEST认证）</li><li>403 Forbidden<br>  请求的资源被服务器拒绝，且没有给出拒绝理由</li><li>404 Not Found<br>  服务器上没有请求的资源</li></ul></li><li><h2 id="5XX-服务器错误-Server-Error"><a href="#5XX-服务器错误-Server-Error" class="headerlink" title="5XX 服务器错误 Server Error"></a>5XX 服务器错误 Server Error</h2><ul><li>500 Internal Server Error<br>  服务器执行请求发生错误</li><li>503 Service Unavailable<br>  服务器繁忙，超负载或正停机维护</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
          <category> 技术类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读笔记 </tag>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读《图解HTTP》第一、二章阅读笔记</title>
      <link href="202102/read-book-diagram-http-1/"/>
      <url>202102/read-book-diagram-http-1/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202102/read-book-diagram-http-1/cover.png" class="" width="0" height="0"><p>常常看技术类相关书籍时，往往在日常工作中接触较少的理论部分会因为少用及与实践相结合去印证而遗忘。所以也希望将理论知识通过阅读总结出笔记、并应用于实践，进一步将知识沉淀。</p><h1 id="TCP-IP-协议族"><a href="#TCP-IP-协议族" class="headerlink" title="TCP/IP 协议族"></a>TCP/IP 协议族</h1><p>计算机及网络设备间的相互通信，需要基于相同的方法。就如同与人沟通的前提是基于一种双方都会的语言一样；TCP/IP 就是互联网相关连的协议集合总称，其包括了 TCP、UDP、HTTP、FTP 等。</p><h2 id="TCP-IP-协议族的分层管理"><a href="#TCP-IP-协议族的分层管理" class="headerlink" title="TCP/IP 协议族的分层管理"></a>TCP/IP 协议族的分层管理</h2><p>TCP/IP 协议族的层次分应用层、传输层、网络层和数据链路层，其各层的作用如下：</p><ol><li>应用层：决定了向用户提供的应用服务时通信活动，如（HTTP,FTP）</li><li>传输层：对应用层提供网络连接中的的数据传输，存在两个性质不同的协议：TCP 与 UDP</li><li>网络层：用来处理网络上流动的数据包，规定了数据包的传输路线</li><li>链路层：处理连接网络的硬件部分。包括控制操作系统、硬件设计驱动、网卡及光纤等物理可见部分。</li></ol><blockquote><p>TCP/IP 的层次化可以让设计协议时相对简单，各层各司其职，更换时也仅需替换需变动的层即可。</p></blockquote><h2 id="TCP-IP-传输流"><a href="#TCP-IP-传输流" class="headerlink" title="TCP/IP 传输流"></a>TCP/IP 传输流</h2><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202102/read-book-diagram-http-1/tcp-ip_transform_flow.png" class="" width="500"><p>如上图所示：<br>发送端会由应用层向下添加每层的首部，再由接收端从链路层向上读取首部及删除每层首部</p><h1 id="与-HTTP-关系密切的协议：-IP、TCP-和-DNS"><a href="#与-HTTP-关系密切的协议：-IP、TCP-和-DNS" class="headerlink" title="与 HTTP 关系密切的协议： IP、TCP 和 DNS"></a>与 HTTP 关系密切的协议： IP、TCP 和 DNS</h1><p>先放 HTTP 协议的传输流</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202102/read-book-diagram-http-1/http_flow.png" class=""><ul><li><h2 id="IP（Internet-Protocol）网际协议"><a href="#IP（Internet-Protocol）网际协议" class="headerlink" title="IP（Internet Protocol）网际协议"></a>IP（Internet Protocol）网际协议</h2><p>属于网络层，几乎所有的网络系统都会用到 IP 协议；<br>IP 协议的作用是把各种数据包传送给对方。需要满足各类条件；其中两个重要条件就是 <code>IP地址</code> 与 <code>MAC地址</code></p><ul><li>IP 地址：指节点被分配到的地址，可发生变换。</li><li>MAC 地址：网卡出厂时固定的地址，基本上不会更改。</li></ul></li></ul><blockquote><p>IP 与 IP 地址 的含义：IP 是指协议，IP 地址是指节点被分配到的地址。</p></blockquote><ul><li><h2 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h2><p>IP 协议依赖于 MAC 地址，但通信双方在同一局域网（LAN）内的情况很少，通常需要经过多台的计算机与网络设备中转才能连接到双方。<br>ARP 协议的功能主要是将 IP 地址解析为 MAC 地址，当前域下无法解析及交给路由进行中转至下一个路由解析，直至获取 MAC 地址成功。</p></li><li><h2 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h2><p>TCP 协议位于传输层，提供可靠的字节流服务（Byte Stream Service）。为确保数据准确可靠的传给对方，TCP 协议将大数据分割，并确认最终是否送达。</p><p>TCP 协议采用三次握手策略。以确保信息完整送达给接收方</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202102/read-book-diagram-http-1/tcp_three_way_handshaking.jpg" class="" width="500"></li><li><h2 id="DNS-协议"><a href="#DNS-协议" class="headerlink" title="DNS 协议"></a>DNS 协议</h2><p>DNS 服务与 HTTP 协议一同位于应用层的协议。它提供域名到 IP 地址的解析服务。</p></li></ul><h1 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h1><blockquote><p>URI 格式：<br>    <a href="https://user:pass@www.example.com:80/dir/index.html?uid=1#hash">https://user:pass@www.example.com:80/dir/index.html?uid=1#hash</a><br>    [协议名]://[认证信息]@[服务器地址]:[端口]/[文件路径]?[查询字符串]#[片段标识符]</p></blockquote><h1 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h1><p>请求访问文本或图像等资源的一端为客户端，提供资源响应的一端称为服务器端。HTTP 协议会明确区分客户端方与服务端方<br>请求必定是由客户端发出后服务端回应返回资源</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202102/read-book-diagram-http-1/http_communicate.png" class=""><h1 id="HTTP-方法"><a href="#HTTP-方法" class="headerlink" title="HTTP 方法"></a>HTTP 方法</h1><table><thead><tr><th align="left">方法</th><th align="left">描述</th><th align="left">HTTP 版本支持</th></tr></thead><tbody><tr><td align="left">GET</td><td align="left">传输内容消息、返回访问的资源</td><td align="left">1.0/1.1</td></tr><tr><td align="left">POST</td><td align="left">传输内容消息</td><td align="left">1.0/1.1</td></tr><tr><td align="left">HEAD</td><td align="left">获取报文首部，用于确认 URI 有效性及资源更新日期</td><td align="left">1.0/1.1</td></tr><tr><td align="left">PUT</td><td align="left">传输文件（因不带验证机制，存在安全性问题，配合 REST 标准运用可开放）</td><td align="left">1.0/1.1</td></tr><tr><td align="left">DELETE</td><td align="left">删除文件，同 PUT 一样不带验证机制，需配合 REST 开放</td><td align="left">1.0/1.1</td></tr><tr><td align="left">OPTIONS</td><td align="left">访问支持的方法</td><td align="left">1.1</td></tr><tr><td align="left">TRACE</td><td align="left">追踪路径，因易引发 XST 攻击，通常不用</td><td align="left">1.1</td></tr><tr><td align="left">CONNECT</td><td align="left">与代理服务器通信时建立隧道，WEB 开发中基本用不上</td><td align="left">1.1</td></tr></tbody></table><blockquote><p>扩展阅读：<a href="https://zhuanlan.zhihu.com/p/61990354">TRACE XST 攻击原理</a> | <a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1105000713418592">REST</a></p></blockquote><h1 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h1><p>最初的 HTTP 协议因仅需满足很小的文本传输，所以每进行一次 HTTP 通信就会断开一次，现代网页包含了更大的文本传输及资源传输，会造成较大的通信量开销。</p><p>为此 <code>HTTP/1.1</code>及<code>部分的HTTP/1.0</code> 制定了持久连接的方法；只要做任意一端未明确提出断开连接，则保持 TCP 连接状态。</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202102/read-book-diagram-http-1/http_keep_alive.png" class="" width="500"><blockquote><p>HTTP/1.1 中，所有的连接默认都是持久连接，但 HTTP/1.0 内并未标准化，一部分服务器通过非标准手段实现了持久连接，但持久连接需要客户端与服务端的同时支持。</p></blockquote><ul><li><h2 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h2>可同时并行发送多个请求，不用等待响应即可发送下一个请求<img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202102/read-book-diagram-http-1/http_pipelining.jpg" class=""></li></ul><h1 id="Cookie-状态管理"><a href="#Cookie-状态管理" class="headerlink" title="Cookie 状态管理"></a>Cookie 状态管理</h1><p>HTTP 为无状态协议，它不对之前发生的请求和响应状态进行管理，将各客户端的状态都存读在服务端，服务器自然也是伤不起的。<br>因 HTTP 协议 本身非常简单的，所以才被多种场景应用。在保留无状态协议特征同时引入了 Cookie 技术。</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202102/read-book-diagram-http-1/http_cookie.png" class=""><p>Cookie 会根据从服务器发送的响应报文内增加 Set-Cookie 首部字段信息，通知客户端存储，当客户端发出下一次的请求时，存储的 Cookie 会自动加入到请求报文中发送出去。</p><ol><li><strong>请求报文</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">get &#x2F;reader HTTP&#x2F;1.1<br>Host example.com<br>#首部字段内无Cookie相关信息<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>响应报文</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">HTTP&#x2F;1.1 200 OK<br>Date: Thu, 12 Jul 2012 07:12:20 GMT<br>Server: Nginx<br>&lt;Set-Cookie:sid&#x3D;123456789;path&#x3D;&#x2F;;expires&#x3D;Wed,10-Oct-12 07:12:20 GMT&gt;<br>Content-Type: text&#x2F;plain; charset&#x3D;UTF-8<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>请求报文</strong>(自动发送保存的 Cookie 信息)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">get &#x2F;reader HTTP&#x2F;1.1<br>Host example.com<br>Cookie:sid&#x3D;123456789<br></code></pre></td></tr></table></figure><h1 id="继续阅读"><a href="#继续阅读" class="headerlink" title="继续阅读"></a>继续阅读</h1><ul><li><a href="/202102/read-book-diagram-http-2/" title="读《图解HTTP》第三、四章阅读笔记">读《图解HTTP》第三、四章阅读笔记</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
          <category> 技术类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读笔记 </tag>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vuex实现历史记录</title>
      <link href="202101/vuex-develop-history/"/>
      <url>202101/vuex-develop-history/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202101/vuex-develop-history/cover.png" class="" width="0" height="0"><p>最近自研着一个可视化操作平台，其中涉及到用户操作后可撤销或重做，在网上搜了一些解决思路，完善自己所设想的解决思路。</p><h2 id="历史记录需求的要点"><a href="#历史记录需求的要点" class="headerlink" title="历史记录需求的要点"></a>历史记录需求的要点</h2><ul><li>可存储在 localStorage 中</li><li>可多次撤销或多次重做</li><li>点击列表中的一项，将历史倒退或前进至指定位置</li></ul><p>看似简单的需求，在基础建设设计上的错误，亦会在未来导致更多的工作量。所以结合上面两点的要求，发现 vuex 的基本思路非常适合完成这个需求，redux 同样。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><blockquote><p>此项目用了 typescript 来加强代码的严谨性，方便日后维护，大家简单看个思路。</p></blockquote><h3 id="1-先定义历史记录的数据结构"><a href="#1-先定义历史记录的数据结构" class="headerlink" title="1. 先定义历史记录的数据结构"></a>1. 先定义历史记录的数据结构</h3>  <figure class="highlight typescript"><figcaption><span>vue.d.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> HistoryItem &#123;<br>  timestrap: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 记录时间戳</span><br>  name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 记录名称</span><br>  redo: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 重做Mutation</span><br>  undo: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 撤销Mutation</span><br>  redoParams: <span class="hljs-built_in">any</span>[]; <span class="hljs-comment">// 重做Mutation提交参数</span><br>  undoParams: <span class="hljs-built_in">any</span>[]; <span class="hljs-comment">// 撤销Mutation提交参数</span><br>&#125;<br><br><span class="hljs-keyword">interface</span> HistoryStatus &#123;<br>  historys: HistoryItem[]; <span class="hljs-comment">// 记录history数组</span><br>  _currentHistory: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 当前节点索引</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-编写-History-状态模块"><a href="#2-编写-History-状态模块" class="headerlink" title="2. 编写 History 状态模块"></a>2. 编写 History 状态模块</h3><p>  编写基础操作history状态的vuex <code>module</code>，创建记录的<code>Mutation</code>，重做和撤销的Action</p><blockquote><p>一条记录是包含对这个步骤的执行<code>redo</code>操作与撤销<code>undo</code>操作的。所以在用户点击列表其中一项时，应该是循环回退到当前项的前一项undo，或循环redo到当前项<br>所以需要增加一条空记录，方便用户点击空记录撤销最初的操作。</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202101/vuex-develop-history/history_dialog.png" class=""><p>运用了<code>vuex-module-decorators</code> 装饰器，写更易维护的代码</p></blockquote>  <figure class="highlight typescript"><figcaption><span>store/modules/History.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; VuexModule, Module, Mutation, Action &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vuex-module-decorators&quot;</span>;<br><br><span class="hljs-meta">@Module</span>(&#123; <span class="hljs-attr">namespaced</span>: <span class="hljs-literal">true</span> &#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HistoryModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">VuexModule</span>&lt;<span class="hljs-title">HistoryStatus</span>&gt; <span class="hljs-title">implements</span> <span class="hljs-title">HistoryStatus</span> </span>&#123;<br>  <span class="hljs-comment">/** </span><br><span class="hljs-comment">   * 初始化一个空记录的原因主要是方便列表操作时：</span><br><span class="hljs-comment">   * 当用户点击最早的一条记录时，可以正常撤销用户操作的第一步</span><br><span class="hljs-comment">  **/</span><br>  <span class="hljs-keyword">public</span> historys: HistoryItem[] = [<br>    &#123;<br>      name: <span class="hljs-string">`打开`</span>,<br>      timestrap: <span class="hljs-built_in">Date</span>.now(),<br>      redo: <span class="hljs-string">&quot;&quot;</span>,<br>      redoParams: [],<br>      undo: <span class="hljs-string">&quot;&quot;</span>,<br>      undoParams: [],<br>    &#125;,<br>  ];<br>  <span class="hljs-keyword">public</span> _currentHistory: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// getter</span><br>  <span class="hljs-keyword">get</span> <span class="hljs-title">current</span>()&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._currentHistory;<br>  &#125;<br><br>  <span class="hljs-comment">// getter</span><br>  <span class="hljs-keyword">get</span> <span class="hljs-title">historyList</span>(): <span class="hljs-title">HistoryItem</span>[] &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.historys || [];<br>  &#125;<br><br>  <span class="hljs-comment">// 创建历史记录</span><br>  <span class="hljs-meta">@Mutation</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">CREATE_HISTORY</span>(<span class="hljs-params">payload: HistoryItem</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>._currentHistory &lt; <span class="hljs-built_in">this</span>.historys.length - <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-built_in">this</span>.historys = <span class="hljs-built_in">this</span>.historys.slice(<span class="hljs-number">0</span>, <span class="hljs-built_in">this</span>._currentHistory);<br>    &#125;<br>    <span class="hljs-comment">// 由于js的深浅拷贝问题，所以在创建时都需要对数据进行深拷贝</span><br>    <span class="hljs-comment">// 想尝试lodash的clone函数，但发现好像JSON.stringify的方式clone应该更快的，毕竟我们的数据不存在函数</span><br>    <span class="hljs-comment">// 我这里就先不改了，主要是表达出思路即可</span><br>    <span class="hljs-built_in">this</span>.historys.push(_.cloneDeep(payload));<br>    <span class="hljs-built_in">this</span>._currentHistory = <span class="hljs-built_in">this</span>.historys.length - <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-meta">@Mutation</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">SET_CURRENT_HISTORY</span>(<span class="hljs-params">index: <span class="hljs-built_in">number</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>._currentHistory = index &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : index;<br>  &#125;<br><br>  <span class="hljs-comment">// 重做</span><br>  <span class="hljs-meta">@Action</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">RedoHistory</span>(<span class="hljs-params">times: <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span></span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> &#123; state, commit &#125; = <span class="hljs-built_in">this</span>.context;<br>    <span class="hljs-keyword">let</span> historys: HistoryItem[] = state.historys;<br>    <span class="hljs-keyword">let</span> current: <span class="hljs-built_in">number</span> = state._currentHistory;<br>    <span class="hljs-keyword">if</span> (current + times &gt;= historys.length) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">while</span> (times &gt; <span class="hljs-number">0</span>) &#123;<br>      current++;<br>      <span class="hljs-keyword">let</span> history = historys[current];<br>      <span class="hljs-keyword">if</span> (history) &#123;<br>        commit(history.redo, ...history.redoParams, &#123; <span class="hljs-attr">root</span>: <span class="hljs-literal">true</span> &#125;);<br>      &#125;<br>      times--;<br>    &#125;<br>    commit(<span class="hljs-string">&quot;SET_CURRENT_HISTORY&quot;</span>, current);<br>  &#125;<br><br>  <span class="hljs-comment">// 撤销</span><br>  <span class="hljs-meta">@Action</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">UndoHistory</span>(<span class="hljs-params">times: <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span></span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> &#123; state, commit &#125; = <span class="hljs-built_in">this</span>.context;<br>    <span class="hljs-keyword">let</span> historys: HistoryItem[] = state.historys;<br>    <span class="hljs-keyword">let</span> current: <span class="hljs-built_in">number</span> = state._currentHistory;<br>    <span class="hljs-keyword">if</span> (current - times &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">while</span> (times &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">let</span> history = historys[current];<br>      <span class="hljs-keyword">if</span> (history) &#123;<br>        commit(history.undo, ...history.undoParams, &#123; <span class="hljs-attr">root</span>: <span class="hljs-literal">true</span> &#125;);<br>      &#125;<br>      times--;<br>      current--;<br>    &#125;<br>    commit(<span class="hljs-string">&quot;SET_CURRENT_HISTORY&quot;</span>, current);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-编写可以撤销或重做的功能"><a href="#3-编写可以撤销或重做的功能" class="headerlink" title="3. 编写可以撤销或重做的功能"></a>3. 编写可以撤销或重做的功能</h3><p>  完成上面两步后，我们就可以编写各种操作了</p><ol><li><p>编写对数据基础操作的<code>Mutation</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Mutation</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">CREATE_PAGE</span>(<span class="hljs-params">payload: &#123; page: PageItem; index: <span class="hljs-built_in">number</span> &#125;</span>)</span> &#123;<br>  <span class="hljs-built_in">this</span>.pages.splice(payload.index, <span class="hljs-number">0</span>, _.cloneDeep(payload.page));<br>  <span class="hljs-built_in">this</span>._currentPage = <span class="hljs-built_in">this</span>.pages.length - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-meta">@Mutation</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">REMOVE_PAGE</span>(<span class="hljs-params">id: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>  <span class="hljs-keyword">let</span> index = <span class="hljs-built_in">this</span>.pages.findIndex(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> p.id == id);<br>  index &gt; -<span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">this</span>.pages.splice(index, <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>._currentPage == index) &#123;<br>    <span class="hljs-built_in">this</span>._currentPage = <span class="hljs-built_in">this</span>.pages.length &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : -<span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>将基础操作按要求封装成带保存-&gt;记录-&gt;执行的<code>Action</code></p><figure class="highlight typescript"><figcaption><span>store/modules/Page.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 包装创建页面函数</span><br><span class="hljs-meta">@Action</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">CreatePage</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>: <span class="hljs-string">&quot;page&quot;</span> | <span class="hljs-string">&quot;dialog&quot;</span></span>)</span> &#123;<br>  <span class="hljs-keyword">let</span> &#123; state, commit &#125; = <span class="hljs-built_in">this</span>.context;<br>  <br>  <span class="hljs-comment">// 记录保存即将创建的页面</span><br>  <span class="hljs-keyword">let</span> id = _.uniqueId(<span class="hljs-keyword">type</span>) + <span class="hljs-built_in">Date</span>.now();<br>  <span class="hljs-keyword">let</span> pageName = pageType[<span class="hljs-keyword">type</span>];<br>  <span class="hljs-keyword">let</span> page: PageItem = &#123;<br>    id,<br>    name: <span class="hljs-string">`<span class="hljs-subst">$&#123;pageName&#125;</span><span class="hljs-subst">$&#123;state.pages.length + <span class="hljs-number">1</span>&#125;</span>`</span>,<br>    <span class="hljs-keyword">type</span>,<br>    layers: [],<br>    style: &#123; <span class="hljs-attr">width</span>: <span class="hljs-number">720</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">1280</span> &#125;,<br>  &#125;;<br><br>  <span class="hljs-comment">//创建历史记录</span><br>  <span class="hljs-keyword">let</span> history: HistoryItem = &#123;<br>    name: <span class="hljs-string">`创建<span class="hljs-subst">$&#123;pageName&#125;</span>`</span>,<br>    timestrap: <span class="hljs-built_in">Date</span>.now(),<br>    redo: <span class="hljs-string">&quot;Page/CREATE_PAGE&quot;</span>,<br>    redoParams: [&#123; <span class="hljs-attr">index</span>: state.pages.length - <span class="hljs-number">1</span>, page &#125;],<br>    undo: <span class="hljs-string">&quot;Page/REMOVE_PAGE&quot;</span>,<br>    undoParams: [id],<br>  &#125;;<br>  <span class="hljs-comment">// 保存记录此历史记录</span><br>  commit(<span class="hljs-string">&quot;Histroy/CREATE_HISTORY&quot;</span>, history, &#123; <span class="hljs-attr">root</span>: <span class="hljs-literal">true</span> &#125;);<br><br>  commit(history.redo, ...history.redoParams, &#123; <span class="hljs-attr">root</span>: <span class="hljs-literal">true</span> &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><figcaption><span>store/modules/Page.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Action</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">RemovePage</span>(<span class="hljs-params">id: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>  <span class="hljs-comment">// 记录保存现场状态</span><br>  <span class="hljs-keyword">let</span> index = <span class="hljs-built_in">this</span>.pages.findIndex(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> p.id == id);<br>  <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">let</span> page: PageItem = <span class="hljs-built_in">this</span>.context.state.pages[index];<br><br>  <span class="hljs-comment">//创建历史记录</span><br>  <span class="hljs-keyword">let</span> history: HistoryItem = &#123;<br>    name: <span class="hljs-string">`删除 <span class="hljs-subst">$&#123;page.name&#125;</span>`</span>,<br>    timestrap: <span class="hljs-built_in">Date</span>.now(),<br>    redo: <span class="hljs-string">&quot;Page/REMOVE_PAGE&quot;</span>,<br>    redoParams: [id],<br>    undo: <span class="hljs-string">&quot;Page/CREATE_PAGE&quot;</span>,<br>    undoParams: [&#123; page, index &#125;],<br>  &#125;;<br><br>  <span class="hljs-comment">// 保存记录此历史记录</span><br>  <span class="hljs-built_in">this</span>.context.commit(<span class="hljs-string">&quot;Histroy/CREATE_HISTORY&quot;</span>, history, &#123; <span class="hljs-attr">root</span>: <span class="hljs-literal">true</span> &#125;);<br>  <span class="hljs-built_in">this</span>.context.commit(history.redo, ...history.redoParams, &#123; <span class="hljs-attr">root</span>: <span class="hljs-literal">true</span> &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上，撤销与重做的功能就基本完成了</p><h3 id="4-使用"><a href="#4-使用" class="headerlink" title="4. 使用"></a>4. 使用</h3><ol><li>我们现在只需要在使用时创建或删除页面时使用封装的<code>Action</code>后</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">create</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>: <span class="hljs-string">&quot;page&quot;</span> | <span class="hljs-string">&quot;dialog&quot;</span></span>)</span> &#123;<br>  <span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&quot;Page/CreatePage&quot;</span>, <span class="hljs-keyword">type</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">remove</span>(<span class="hljs-params">id: <span class="hljs-built_in">number</span></span>)</span> &#123;<br>  <span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&quot;Page/RemovePage&quot;</span>, id);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>配置全局热键</li></ol><figure class="highlight typescript"><figcaption><span>App.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript">...<br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">let</span> self = <span class="hljs-built_in">this</span>;<br>  hotkeys(<span class="hljs-string">&quot;ctrl+z&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event, handler</span>) </span>&#123;<br>    self.$store.dispatch(<span class="hljs-string">&quot;History/UndoHistory&quot;</span>);<br>  &#125;);<br>  hotkeys(<span class="hljs-string">&quot;ctrl+y&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event, handler</span>) </span>&#123;<br>    self.$store.dispatch(<span class="hljs-string">&quot;History/RedoHistory&quot;</span>);<br>  &#125;);<br>&#125;<br>...<br></code></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202101/vuex-develop-history/effect.gif" class=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
          <category> WEB开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 思路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>朋友安利的一款轻量级docker容器可视化管理</title>
      <link href="202101/recommend-portainer/"/>
      <url>202101/recommend-portainer/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202101/recommend-portainer/cover.png" class="" width="0" height="0"><p>刚开始玩docker及linux玩的少我来说，有可视化的Docker管理工具真的不要太香了。</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202101/recommend-portainer/portainer.png" class=""><h1 id="安装并运行-portainer-镜像"><a href="#安装并运行-portainer-镜像" class="headerlink" title="安装并运行 portainer 镜像"></a>安装并运行 portainer 镜像</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 拉取portainer镜像</span><br>docker pull docker pull portainer/portainer-ce<br><span class="hljs-comment"># 创建 portainer_data docker volume目录</span><br>docker volume create portainer_data<br><span class="hljs-comment"># 创建运行portainer容器</span><br>docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce<br><span class="hljs-comment"># -d 后台运行</span><br><span class="hljs-comment"># -p 映射8000与9000的端口</span><br><span class="hljs-comment"># --name 容器名称</span><br><span class="hljs-comment"># --restart=always docker重启时自动启动容器</span><br><span class="hljs-comment"># -v 映射本地docker.sock 及 新创建的portainer_data volume目录</span><br></code></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>安装完成后，通过 <a href="http://ip:9000/">http://ip:9000/</a> 即可访问，设置服务的用户名密码后</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202101/recommend-portainer/set_user.png" class=""><p>前面的映射中已将docker.sock映射了，所以我们直接选择 <code>Local</code> 后 <code>connect</code> 就可以直接享用啦</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202101/recommend-portainer/bind_docker_sock.png" class="">]]></content>
      
      
      <categories>
          
          <category> 服务运维 </category>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker部署GitLab遇到的问题</title>
      <link href="202101/docker-gitlab/"/>
      <url>202101/docker-gitlab/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202101/docker-gitlab/cover.png" class="" width="0" height="0"><h1 id="啰哩啰嗦"><a href="#啰哩啰嗦" class="headerlink" title="啰哩啰嗦"></a>啰哩啰嗦</h1><p>玩上 docker 后，开始热衷于在上面架设各种服务来玩。就想着搞个 gitlab 来玩玩好了。不过我朋友也劝我没必要，因为我们个人的容灾手段还是有限的，为此，我机智的想到一招，直接镜像到 github 或者是 coding 之类的 git 平台，这样就不怕万一真出现了的数据灾难啦。<br>毕竟技术无国界还是要分情况的，github封禁伊朗籍的账户的事件还是值得警惕，虽说我个小人物，但我还是不想遇到万一需要迁移的麻烦事；代码放在自己的物理硬盘的手段还是必要的。</p><p>这篇文章主要<del>水的</del>原因在于我直接安装配置完gitlab后，遇到的几个迷之问题，与找到的解决方案。</p><ul><li><p>发现gitlab页面中部分链接总是会跳到无端口的页面中，自然也就是404了，甚至不知如何搜这个问题，在莫名的契机下，找到了解决方案，其实也是个很基础的配置问题。</p><blockquote><p><a href="https://segmentfault.com/a/1190000021229534">通过 Docker 快速部署公司内部 GitLab</a></p></blockquote></li><li><p>可能是我安装的gitlab版本问题，我的gitlab还没多少项目存放，每天却按 1G 以上的大小占用了我的硬盘，GITLAB是架设在本地机子中的 VM虚拟机的 ，暂时没空解决这个问题，就只好先对虚拟机扩容了。</p><blockquote><p>抽空后，发现gitlab应该下的prometheus文件夹大到爆炸，通过查询prometheus的必要性后，我对其直接停用处理了。</p></blockquote></li></ul><h1 id="安装并运行-gitlab-镜像"><a href="#安装并运行-gitlab-镜像" class="headerlink" title="安装并运行 gitlab 镜像"></a>安装并运行 gitlab 镜像</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 拉取gitlab镜像</span><br>docker pull gitlab/gitlab-ce<br><br><span class="hljs-comment"># 为 gitlab 创建 2 个docker volume目录： gitlab_data 和 gitlab_config</span><br>docker volume create gitlab_data<br>docker volume create gitlab_config<br><br><span class="hljs-comment"># 个人是私用的gitlab，所以端口之类自然也不可以直接用gitlab默认的。</span><br>docker run -d  -p 8443:443 -p 3300:80 -p 1011:22 --name gitlab --restart always -v gitlab_config:/etc/gitlab -v gitlab_data:/var/opt/gitlab gitlab/gitlab-ce<br><span class="hljs-comment"># -d 后台运行</span><br><span class="hljs-comment"># -p [映射端口]:[容器端口]</span><br><span class="hljs-comment"># --name 容器名称</span><br><span class="hljs-comment"># --restart=always docker重启时自动启动容器</span><br><span class="hljs-comment"># -v 映射gitlab_data和gitlab_config volume目录</span><br></code></pre></td></tr></table></figure><h1 id="配置gitlab-rb"><a href="#配置gitlab-rb" class="headerlink" title="配置gitlab.rb"></a>配置gitlab.rb</h1><p>gitlab容器运行没问题后，在gitlab上创建项目的时候，生成项目的URL访问地址是按容器的hostname来生成的，所以也就无法正常的克隆、拉取、提交了。我们还需要更新一下配置后重启gitlab</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 通过直接进入挂载文件夹修改</span><br>vim &#123;volumn_dir&#125;/gitlab_data/_data/gitlab.rb<br><br><span class="hljs-comment"># 进入容器修改</span><br>docker <span class="hljs-built_in">exec</span> -it gitlab bash<br>vim /etc/gitlab/gitlab.rb<br></code></pre></td></tr></table></figure><blockquote><p>小提示（会VIM的略过吧）：<br>按下 <code>/ 键</code> 并输入要搜索的字符后 <code>回车键</code>，<code>n 键</code> 查看下一条 <code>shift + n 键</code> 查看上一条<br>按下 <code>i 键</code> 进入编辑模式，编辑完成后 <code>Esc 键</code> 退出编辑模式<br>非编辑模式下 输入 :wq 保存文档</p></blockquote><figure class="highlight bash"><figcaption><span>gitlab.rb</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 修改如下语句</span><br>external_url <span class="hljs-string">&#x27;http://[ip/hostname]:3300&#x27;</span><br><br><span class="hljs-comment"># nginx默认会去external_url中获取端口用以访问，但我们窗口只映射了80，所以还需要nginx指向的端口到80</span><br>nginx[<span class="hljs-string">&#x27;listen_port&#x27;</span>] = 80<br><span class="hljs-comment"># https需要下面这句</span><br><span class="hljs-comment"># nginx[&#x27;redirect_http_to_https_port&#x27;] = 443</span><br><br><span class="hljs-comment"># 配置 1011 端口</span><br>gitlab_rails[<span class="hljs-string">&#x27;gitlab_shell_ssh_port&#x27;</span>] = 1011<br><span class="hljs-comment"># 停用prometheus</span><br>prometheus_monitoring[<span class="hljs-string">&#x27;enable&#x27;</span>] = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>按上述修改完成后 重启gitlab就可以啦</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker restart gitlab<br></code></pre></td></tr></table></figure><p>以上基本gitlab的访问配置就完成了。接下来就自行访问可视化配置进行配置吧。</p><h1 id="我的gitlab最终效果"><a href="#我的gitlab最终效果" class="headerlink" title="我的gitlab最终效果~"></a>我的gitlab最终效果~</h1><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202101/docker-gitlab/result.png" class="">]]></content>
      
      
      <categories>
          
          <category> 服务运维 </category>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stylus-shortcut 加速编写 CSS</title>
      <link href="202012/stylus-shortcut/"/>
      <url>202012/stylus-shortcut/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202012/stylus-shortcut/cover.png" class="" width="0" height="0"><p>stylus-shortcut 可以加速编写 CSS，通过 stylus 中 mixin 的功能，将样式常用组合合并汇以简单一句，减少代码的编写量；并通过 stylus 循环将常用主题变量生成常用的样式规则，可快捷使用。</p><ul><li><strong><a href="https://kwokronny.top/stylus-shortcut-document/">说明文档</a></strong></li><li><strong><a href="https://github.com/hiyoz/stylus-shortcut">项目仓库</a></strong></li></ul><h2 id="开发意图"><a href="#开发意图" class="headerlink" title="开发意图"></a>开发意图</h2><p>编写这个项目最初的目的是在开发一 SAAS 平台时，我已采用 iviewUI 的基础上进行开发，并通过自定义主题覆盖了部分样式及颜色变量后。常常需要在部分元素上为元素命名后仅仅为其加一项间距属性或文本颜色等简单的样式。来回切换样式文件与 DOM 文件，及为不重要的小元素命名，多而烦；或许这也是为什么 Bootstrap 可以一下成为大家热爱的库吧。</p><p>所以我简单通过 stylus 的循环按设计规范中常用的间距生成了多个间距样式及颜色样式，真的非常的方便与快落；事实证明频繁的切换文件是容易忘记自己需要做什么的。<br>再之后，为一些复杂的设计编写样式时，常常在写完 width 时基本下一句可能就是 height，嗒嗒嗒下来，写了许多行，但常常这些伴随着规律，定位时会写 left,top、宽高写完时可能还会再设置个圆角等，写了几年前端后早已厌烦了长长的样式规则。<br>所以我通过 stylus 的 mixin 功能，将编写 CSS 时常用的规律汇成一句，小小的功能，也可以提升大大的效率。<br>编写文档时，也常问自己项目如此的小，是否需要变成一个库呢？我找到了答案，小而简就是这个项目的初心，他解决的是开发中常常忽视的小烦恼，整理出规律增加编写效率也是这个小项目最重要的核心<br>如果你也同我一样存在这些厌烦，不妨试试这个库哟~</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>通过 stylus 的特性整理开发的一套加速样式编写的解决方案</li><li>可快速将设计中常用的规范转化为变量生成常用的样式</li><li>命名规则应用尊循 BEM</li><li>小而美，只解决常见但小的麻烦</li></ul><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;your-custom-variable-file.styl&quot;</span> <span class="hljs-comment">//引入自定义变量</span><br><span class="hljs-comment">// 同时引入 shortcut.styl mixin.styl</span><br><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;~@hiyoz/stylus-shortcut&quot;</span><br><span class="hljs-comment">// or 单独引入 shortcut.styl</span><br><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;~@hiyoz/stylus-shortcut/src/shortcut.styl</span><br><span class="hljs-string">// or 单独引入 mixin.styl</span><br>@import &quot;~@hiyoz/stylus-shortcut/src/mixin.styl<br></code></pre></td></tr></table></figure><blockquote><p>变量与mixin需要在多文件下自动引用可通过stylus-loader<br>如 vue-cli@3 配置示例，在 stylus-loader 中配置 import 全局引入</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//vue.config.js</span><br>modules.export=&#123;<br>  ...<br>  css: &#123;<br>    <span class="hljs-comment">// 配置css模块</span><br>    loaderOptions: &#123;<br>      <span class="hljs-comment">// 向预处理器 Loader 传递配置选项</span><br>      stylus: &#123;<br>        <span class="hljs-keyword">import</span>: [<br>          <span class="hljs-string">&quot;your-custom-variable-file.styl&quot;</span>,<br>          <span class="hljs-string">&quot;@hiyoz/stylus-shortcut/src/mixin.styl&quot;</span><br>        ]<br>      &#125;<br>    &#125;<br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs variable.styl">yoz_color &#x3D; &#123;<br>  primary: #1890ff,<br>  link: #1890ff,<br>  success: #52c41a,<br>  warning: #faad14,<br>  error: #f5222d<br>&#125;;<br>yoz_spacing ?&#x3D; &#123;<br>  &#39;5&#39;: 5px,<br>  &#39;10&#39;: 10px,<br>  &#39;20&#39;: 20px,<br>  &#39;30&#39;: 30px<br>&#125;;<br>...<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;flex-h&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text-c_primary&quot;</span>&gt;</span>文本颜色primary<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--文本颜色为变量值primary--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box bg-c_primary spac-ml_20&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--背景颜色为primary--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box bg-c_primary spac-mh_20&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--水平外间距--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box bg-c_primary spac-p_20&quot;</span>&gt;</span>内间距<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--四边内间距--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
          <category> WEB开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stylus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS预处理哪家强？</title>
      <link href="202012/css-pre-handler/"/>
      <url>202012/css-pre-handler/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202012/css-pre-handler/cover.png" class="" width="0" height="0"><h1 id="不想再回到的CSS时代"><a href="#不想再回到的CSS时代" class="headerlink" title="不想再回到的CSS时代"></a>不想再回到的CSS时代</h1><p>刚学前端时，各预处理软件还没出现，犹记得当时写的最好的 CSS格式是这样</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.panel</span>&#123; <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>; <span class="hljs-attribute">height</span>:<span class="hljs-number">800px</span>; <span class="hljs-attribute">margin</span>: <span class="hljs-number">30px</span> &#125;<br><span class="hljs-selector-class">.panel</span> <span class="hljs-selector-class">.panel-title</span>&#123; <span class="hljs-attribute">font-size</span>: <span class="hljs-number">18px</span>; <span class="hljs-attribute">font-weight</span>:bold; &#125;<br></code></pre></td></tr></table></figure><p>在当时CSS不支持嵌套的时代，这样的CSS规则已经算是简单易看懂的了，但在浏览器商开始逐鹿时，被样式<code>-webkit-</code>、<code>-moz-</code>等前缀弄到臃肿难受。</p><h1 id="各大预处理器的出现"><a href="#各大预处理器的出现" class="headerlink" title="各大预处理器的出现"></a>各大预处理器的出现</h1><p>为了解决日益复杂的交互需求，及更规范的前端工程化，伟大的先驱们开发了许许多多加速工作效率解决方案。</p><p>各大CSS预处理器出现后，我基本每款都在项目中实践应用过，就说说他们的优劣势水水文吧。</p><blockquote><p>产品的优劣很多时候是针对需求而言的，所以以下优劣仅以是针对我个人而言，供大家参考。</p></blockquote><h2 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h2><p>个人最开始使用的预处理语言，当时的 webpack 在我身边刚开始普及，大部分还主要是gulp、grunt的天下，我的前端视界也还未被打开，前后端处于半分离的模式，由后端渲染页面，前端部分交互由接口完成。开始接触到Less的我觉得方便极了，拥有常见的变量，函数，导入，混合，逻辑运算、嵌套等功能，这些功能极大的减少了CSS的编写量，算是非常轻量好上手的预处理工具了。</p><h2 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h2><p>接触Less的同时也了解到有Sass这个更强大的预处理器。但个人对webpack及前端项目工程化还不太熟悉的我先选择了less做为入门先，有了基本的前端工程化思维后才正式开始使用Sass开发项目；Sass给我的感觉是在逻辑运算上，自定义函数等多方面更优于Less，但语法复杂度确实相较于Less难上手许多，语法也更为严谨，但对于个人对CSS预处理器的期望需求仅仅是完成变量，循环，模块化CSS，自定义函数等功能的我来说。Sass过于臃肿，最大烦恼莫过于npm安装时，node-sass在国内环境下无法正常安装，经常出现超时等无法安装的问题，虽说找到过解决方案，但实在是令人难受，CSS作为WEB界面配置的其中一环，使用一门如此麻烦严谨的语言，实在是有些难以接受。</p><h2 id="Stylus"><a href="#Stylus" class="headerlink" title="Stylus"></a>Stylus</h2><p>一次机缘巧合下，接触到了一个项目，项目中运用的CSS预处理语言独树一帜，无花括号，无分号等；其实早前了解时有知道过这个stylus，但当时主要展示的是无花括号及分号的写法，个人到现在其实都不太相信，因为没有界限及通过制表符完成嵌套等语句功能，实在时太容易出问题了。对于文件编码及换行符的未深入了解的鸵鸟人来说。这种不确定性我还是想避免的。事实证明，在刚开始接触这种写法时，还是挺爽的，但可能mac上打的一个奇怪的空格，或换行符等问题，会让你摸不着头脑的找不到出问题的位置。</p><blockquote><p>但这个语言其实亦支持使用花括号及分号，只需要配置格式化工具即可，这样就再也不会有那种因编码等导致的令人头大的问题了</p></blockquote><p><strong>VS Code中的格式化插件是：<a href="https://marketplace.visualstudio.com/items?itemName=thisismanta.stylus-supremacy">Manta’s Stylus Supremacy</a></strong></p><p>至此，这款stylus便是我最爱用的一款预处理工具了，如less般好上手，拥有sass般强大的功能，逻辑循环等语法简单且像js，支持集合变量等，让人爱不释手。下面是我最近有整合的stylus-shortcut库中部分代码，可以通过变量快速完成一套bootstrap式的CSS规则，快速应用。</p><blockquote><a href="/202012/stylus-shortcut/" title="stylus-shortcut 加速编写 CSS">stylus-shortcut 加速编写 CSS</a></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-class">.flex</span> &#123;<br><span class="hljs-variable">$flex_direction</span> = &#123;<br>h: row,<br>h_rtl: row-reverse,<br>v: column,<br>v_rtl: column-reverse<br>&#125;;<br><br><span class="hljs-keyword">for</span> <span class="hljs-variable">$name</span>, <span class="hljs-variable">$value</span> <span class="hljs-keyword">in</span> <span class="hljs-variable">$flex_direction</span> &#123;<br>&amp;-&#123;<span class="hljs-variable">$name</span>&#125; &#123;<br><span class="hljs-attribute">display</span>: flex;<br><span class="hljs-attribute">flex-direction</span>: <span class="hljs-variable">$value</span>;<br>&#125;<br>&#125;<br>&#125;<br><br>yoz_text_align = &#123;<br>  l: <span class="hljs-attribute">left</span>,<br>  r: <span class="hljs-attribute">right</span>,<br>  c: center,<br>  j: justify<br>&#125;;<br><br><span class="hljs-keyword">for</span> <span class="hljs-variable">$name</span>, <span class="hljs-variable">$value</span> <span class="hljs-keyword">in</span> yoz_text_align &#123;<br>  .text-a_&#123;<span class="hljs-variable">$name</span>&#125; &#123;<br>    <span class="hljs-attribute">text-align</span>: <span class="hljs-variable">$value</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> 杂文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安利一款免费好用的开源密码管理软件 - KeePassXC</title>
      <link href="202011/recommend-keepass/"/>
      <url>202011/recommend-keepass/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/cover.png" class="" width="0" height="0"><h2 id="用过的密码管理软件"><a href="#用过的密码管理软件" class="headerlink" title="用过的密码管理软件"></a>用过的密码管理软件</h2><p>推荐前先介绍自己在密码管理上经历过的历程，无兴趣可直接跳过这一段</p><ol><li><h3 id="级别密码制"><a href="#级别密码制" class="headerlink" title="级别密码制"></a>级别密码制</h3><p>统一三个级别的密码，分为：无隐私风险，轻隐私风险，重度隐私风险的密码，密码复杂度按级别升高。方便，只用记三个密码即可尽可能的保护自己的隐私和方便自己的记忆。</p></li><li><h3 id="lastpass"><a href="#lastpass" class="headerlink" title="lastpass"></a>lastpass</h3><p><code>超能小紫</code>最早推荐我用的密码管理的 CHORME 扩展，后来也因为曝出过相关的密码泄漏新闻，所以就试着找个安全些的。</p></li><li><h3 id="1Password"><a href="#1Password" class="headerlink" title="1Password"></a>1Password</h3><p>同样是<code>超能小紫</code>给我安利的，刚好试着免费试用 1 年，试用了几个月，个人在使用上感觉在交互还是不太喜爱，各平台的操作相对不统一，密码生成、删除，修改等操作上有些麻烦，特别是我在新平台注册活登陆时不会自动收集我的信息询问我是否存储，不知是不是我没配置好；这样想想订阅费用还是让我稍稍心痛的。</p></li></ol><h2 id="正式安利-KeePass"><a href="#正式安利-KeePass" class="headerlink" title="正式安利 - KeePass"></a>正式安利 - KeePass</h2><p>KeePass 起初真只是抱着试试的心态，毕竟大概如果有了解的话，KeePass 的相关官网包括网上许多的使用文档中的软件截图，界面风格跟 2000 年基本无异了；我主要电脑是 MacBook 的，一开始还真没打算用这套全平台解决方案，想着再找找，但突然认真看了下网站，发现开源的项目，都有着伟大的开源精神的程序员圈子，一个平台出现了三四种基于 keepass 的第三方版本及各种原生插件。</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/main_big.png" class=""><p>官方版本 KeePass</p><ol><li><h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3>开始试着把以前的密码数据导出后，开始试着转移密码到这个新的解决方案的载体时，官方提供的各平台版本，其实在交互上及实用性上都确认不及<code>1Password</code>所带出的基本功能，各平台间交互差异大，且直接无浏览器扩展的支持，有的也只是已从谷歌官方应用扩展商店下架后，博主间传出的离线版本了；所以还真有点想放弃，老实交钱用回<code>1Password</code>了。</li></ol><blockquote><p>就在我准备放弃前，多搜索了一次。我拥抱了开源<del>穷逼不配1password</del></p></blockquote><ol start="2"><li><h3 id="发现宝藏"><a href="#发现宝藏" class="headerlink" title="发现宝藏"></a>发现宝藏</h3>在一次无意的搜索中，我发现了这款基于<code>KeePass</code>开发的第三方全平台支持的软件版本<a target="_blank" href="https://keepassxc.org/"><center><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/keepassxc-logo.svg" class="" width="100"></center><center style="color:#30782f">KeePassXC</center></a></li></ol><p>一起先看看的截图</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/welcome_screen.png" class=""><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/database_view.png" class=""><h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2><ol><li><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>再放置个<a href="https://keepassxc.org/"><strong>传送门</strong></a><br>根据自己的系统下载匹配的<code>KeePassXC</code>软件,</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/download_page.png" class=""><p>下载后按系统常用方式安装软件即可。</p></li><li><h3 id="生成密码库文件"><a href="#生成密码库文件" class="headerlink" title="生成密码库文件"></a>生成密码库文件</h3><blockquote><p>已用 KeePass 或其他第三方基于 KeePass 的软件生成的密码文件，可跳过此步骤，直接打开食用<br>安装完成后并打开后，如下图所示（软件语言多种，默认跟随系统语言）</p></blockquote><ol><li><p>点击 <code>新建数据库/Create new database</code> 弹出新建窗口</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/welcome_screen.png" class=""></li><li><p>填写数据库名称，点击下一步。</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/create_lib.png" class=""></li><li><p>加密设置，此步骤可直接下一步，亦可详细了解下，毕竟我的隐私不涉及 PY 交易，所以加密复杂度正常就好。（后面想改也可以改）</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/setting_encrypt.png" class=""></li><li><p>密码设置，输入你的主密码，及再次输入后，确认并保存到存储的位置就完成啦。 &gt; 数据库的钥匙，唯一要记住的密码，每次数据库因限定时间未使用时或锁屏离开后锁定时，都需要输入这个密码解锁使用存储的密码。（主密码最好定期更换），有条件的亦可增加硬件设备使用，增强安全性。</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/setting_main_password.png" class=""></li><li><p><strong>最后一个大问题</strong>：密码的存放</p></li></ol><p>因需要多平台使用，密码库的同步尤为重要；需要借助云盘完成。（当然，亦可以自架服务存储并使用）</p><p>推荐云盘：<code>oneDriver</code></p><p>那同步的位置好了后，接下来就只用把生成好的数据库文件放到云盘就 OK 啦。</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/icloud.png" class=""></li><li><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li>查看设置项，设置项可根据自己的习惯配置，我就不一一说明了。</li></ol><blockquote><p>其中需要注意的是 常规-&gt;基础设置-&gt;用户界面 记得勾选<code>最小化而不是退出应用程序</code>，保持程序启动。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/base_setting.png" class=""><ol start="2"><li>下载浏览器扩展并配置连接数据库</li></ol><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/setting_browser.png" class=""><p>如上图按需配置，并按所用的浏览器下载对应的扩展。进入浏览器扩展进行配置绑定即可</p><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/bind_browser.jpg" class=""><ol start="3"><li>当我们打开浏览器登陆时，KeePassXC 会通过匹配链接后询问是否授权信息，确认后，当只有一个密码时就会直接自动输入到输入框了，该平台有多个账号时亦可点击输入框后切换。</li></ol><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/browser_request.png" class=""><img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/recommend-keepass/browser_input.png" class=""><p>还有更多的细节等待你的摸索啦~</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雪碧图命令行工具开发完结撒花</title>
      <link href="202011/sprites-cli-develop/"/>
      <url>202011/sprites-cli-develop/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/sprites-cli-develop/cover.png" class="" width="0" height="0"><h2 id="小图的烦恼"><a href="#小图的烦恼" class="headerlink" title="小图的烦恼"></a>小图的烦恼</h2><p>项目中经常有不可避免的出现小图标，雪碧图依然是很多团队的选择，网上也有了各种各样的雪碧图插件或方案等。但大多数仅仅实现了简易的拼图及规则生成，我在项目中常常遇到两个小图需要在用户交互时切换等甚至更为复杂的需求；终于在百忙<del>懒癌绝症</del>之中搞了一个生成雪碧图的命令行小工具，望大家参考指教。</p><p><a href="https://github.com/hiyoz/sprites-cli">传送门</a></p><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><ul><li><h3 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h3></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install @hiyoz/sprite-cli -g<br><br>sprites-cli [options]<br><br>通过命令对指定目录下的所有结尾 -sprite 结束的雪碧图文件夹，生成雪碧图到指定的生成目录，并生成雪碧图的对应样式文件。支持不同文件夹自定义CSS样式<br><br>Options:<br>  -s, --scope [value]  [必填]设定范围目录，范围目录下所有结尾 -sprite 结束的雪碧图文件夹<br>  -r, --rule [value]   生成sheet规则版本: css less scss stylus，默认使用css若 优先使用雪碧图文件夹下有 template.js 生成规则脚本<br>  -d, --dist [value]   生成目录[范围目录的相对路径]，默认 <span class="hljs-string">&quot;./&quot;</span><br></code></pre></td></tr></table></figure><ul><li><h3 id="基础使用示例"><a href="#基础使用示例" class="headerlink" title="基础使用示例"></a>基础使用示例</h3><p>  <code>demo</code>目录下<code>galaxy-sprite</code>存储了等待合成的雪碧图原料。希望生成stylus的CSS规则文件</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sprites-cli -s demo -r stylus<br></code></pre></td></tr></table></figure><p>  通过命令即可在demo目录下生成galaxy-sprite.styl与galaxy-sprite.png文件。</p></li><li><h3 id="自定义样式生成"><a href="#自定义样式生成" class="headerlink" title="自定义样式生成"></a>自定义样式生成</h3><p>  部分雪碧图在使用时希望支持一定的交互效果，如：某图标在移过去时变换成另一个图标时；即可通过自定义样式生成的方案，在自定义生成符合需求的CSS规则。</p><p>  仅需将在 相应的雪碧图文件夹内 如：<code>[name]-sprite</code>文件夹下，创建<code>template.js</code>文件，代码如下：</p><blockquote><p>当雪碧图文件夹下存在<code>template.js</code>时，该雪碧图文件夹的CSS规则生成仅以此为唯一的生成规则</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">spritesheet</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> spritesCSS = <span class="hljs-string">``</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(spritesheet.sprites)) &#123;<br>    spritesCSS = spritesheet.sprites<br>      .map(<span class="hljs-function">(<span class="hljs-params">sprite</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^van-/</span>.test(sprite.name)) &#123;<br>          name = <span class="hljs-string">`.<span class="hljs-subst">$&#123;sprite.name&#125;</span>`</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          name = <span class="hljs-string">`.&#123;$spriteName&#125;-<span class="hljs-subst">$&#123;sprite.name&#125;</span>`</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^tab-([\w]+)_a$/</span>.test(sprite.name)) &#123;<br>          name = <span class="hljs-string">&quot;.van-tabbar-item--active &quot;</span> + name.replace(<span class="hljs-string">&quot;_a&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/_a$/</span>.test(sprite.name)) &#123;<br>          name = name.replace(<span class="hljs-string">&quot;_a&quot;</span>, <span class="hljs-string">&quot;.active&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">`</span><br><span class="hljs-string">          <span class="hljs-subst">$&#123;name&#125;</span> &#123;</span><br><span class="hljs-string">            <span class="hljs-subst">$&#123;sprite.name.indexOf(<span class="hljs-string">&quot;van-&quot;</span>) &gt; -<span class="hljs-number">1</span> ? <span class="hljs-string">&quot;@extend .&#123;$spriteName&#125;&quot;</span> : <span class="hljs-string">&quot;&quot;</span>&#125;</span></span><br><span class="hljs-string">            background-position: ptr(-<span class="hljs-subst">$&#123;sprite.x&#125;</span>) ptr(-<span class="hljs-subst">$&#123;sprite.y&#125;</span>);</span><br><span class="hljs-string">            width: ptr(<span class="hljs-subst">$&#123;sprite.width&#125;</span>);</span><br><span class="hljs-string">            height: ptr(<span class="hljs-subst">$&#123;sprite.height&#125;</span>);</span><br><span class="hljs-string">          &#125;</span><br><span class="hljs-string">        `</span>;<br>      &#125;)<br>      .join(<span class="hljs-string">&quot;&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">let</span> mainCSS = <span class="hljs-string">`</span><br><span class="hljs-string">      $spriteName= &quot;<span class="hljs-subst">$&#123;spritesheet.name&#125;</span>&quot;</span><br><span class="hljs-string">      .&#123;$spriteName&#125;&#123;</span><br><span class="hljs-string">          position: relative;</span><br><span class="hljs-string">          display: inline-block;</span><br><span class="hljs-string">          font-style: normal;</span><br><span class="hljs-string">          vertical-align: middle;</span><br><span class="hljs-string">          background-image: url(&quot;<span class="hljs-subst">$&#123;spritesheet.image&#125;</span>&quot;);</span><br><span class="hljs-string">          background-size: ptr(<span class="hljs-subst">$&#123;spritesheet.width&#125;</span>) ptr(<span class="hljs-subst">$&#123;spritesheet.height&#125;</span>);</span><br><span class="hljs-string">      &#125;</span><br><span class="hljs-string">      <span class="hljs-subst">$&#123;spritesCSS&#125;</span></span><br><span class="hljs-string">  `</span>;<br>  <span class="hljs-keyword">return</span> [mainCSS, <span class="hljs-string">&quot;styl&quot;</span>]; <span class="hljs-comment">//返回样式规则文本和文件后缀名</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>  这样就可以通过自由的改变逻辑完成多变的需求啦。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
          <category> WEB开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rem响应式网站适配解决方案</title>
      <link href="202011/web-rem-resolve/"/>
      <url>202011/web-rem-resolve/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/kwokronny/kwokronny.github.io@latest/202011/web-rem-resolve/cover.png" class="" width="0" height="0"><h2 id="REM是什么"><a href="#REM是什么" class="headerlink" title="REM是什么"></a>REM是什么</h2><blockquote><p>本文属REM方案的进阶思考，阅读者默认已了解REM方案的原理</p></blockquote><ul><li>搜 <a href="https://www.google.com/search?q=rem+%E6%96%B9%E6%A1%88">Google</a></li><li>搜 <a href="https://www.baidu.com/s?w=rem+%E6%96%B9%E6%A1%88">百度</a></li></ul><h2 id="常见的解决方案"><a href="#常见的解决方案" class="headerlink" title="常见的解决方案"></a>常见的解决方案</h2><ul><li><strong>IDE 插件进行直接转换</strong><ul><li>优点：装好即用</li><li>缺点：不易维护，且大部分情况下无法团队协同，直接修改了源码的数值单位，且一般使用 1rem = 16px 的方案，导致被转换后小数点太多，再次修改时不直观</li></ul></li><li><strong>WebPack Plugin或Loader转换</strong><ul><li>优点：相较于IDE易于团队协作，仅需配置即可直接使用</li><li>缺点：不太支持响应式设置</li></ul></li></ul><h2 id="REM-解决方案"><a href="#REM-解决方案" class="headerlink" title="REM 解决方案"></a>REM 解决方案</h2><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><blockquote><p>以需开发 <em>PC端</em> 和 <em>手机端</em> 的响应式项目为例</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recal</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> docElement = <span class="hljs-built_in">document</span>.documentElement || <span class="hljs-built_in">document</span>.body;<br>    <br>    <span class="hljs-comment">// #region 可根据响应式需求自由调整逻辑</span><br>    <span class="hljs-keyword">let</span> clientWidth = docElement.clientWidth,<br>      designWidth = <span class="hljs-number">1200</span>; <span class="hljs-comment">//PC端设计稿宽度（主内容区域）</span><br><br>    <span class="hljs-keyword">if</span> (clientWidth &lt; <span class="hljs-number">750</span>) &#123; <span class="hljs-comment">// 客户端屏幕宽度小于一定尺寸时</span><br>      designWidth = <span class="hljs-number">640</span>; <span class="hljs-comment">//转为移动端设计稿宽度</span><br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clientWidth &lt; designWidth) &#123;<span class="hljs-comment">// 客户端屏幕宽度小于PC端设计稿时</span><br>      clientWidth -= <span class="hljs-number">80</span> <br>      <span class="hljs-comment">//解决在750~1200左右单独设计的情况，让内容主体与浏览器有空隙</span><br><br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//否则直接应用PC端设计稿宽度</span><br>      clientWidth = designWidth;<br>    &#125;<br>    <span class="hljs-comment">// #region </span><br>    docElement.style.fontSize = (clientWidth / designWidth) * <span class="hljs-number">100</span> + <span class="hljs-string">&quot;px&quot;</span>;<br>  &#125;<br>  <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;resize&quot;</span>, recal);<br>  recal();<br>&#125;)();<br></code></pre></td></tr></table></figure><p><strong>将js代码放在 <code>&lt;head&gt;</code> 内，且不依赖任何插件以保证他最早被执行。</strong></p><p>使用css预处理器编写函数(我这边用的是stylus)</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs styl"><span class="hljs-function"><span class="hljs-title">ptr</span><span class="hljs-params">(px)</span></span>&#123;<br>  return unit((px / 100), &#x27;rem&#x27;);<br>&#125;<br><br>body&#123;<br>  <span class="hljs-attribute">font-size</span>: ptr(<span class="hljs-number">12</span>)<br>&#125;<br><br><span class="hljs-comment">// 使用方法</span><br>.container&#123;<br>  <span class="hljs-attribute">width</span>: ptr(<span class="hljs-number">1200</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h3><p>  通过响应式设计稿尺寸不一的情况下，通过 <code>窗口宽度</code> 变化时判断选用不同端的 <code>设计稿宽度</code> 运算，辅以 <code>css3</code> 的 <code>media</code> 即可完美复现响应式下的设计啦</p><p>  通过 css预处理器的function功能，对单位直接运算，这样就可以愉快的直接将设计稿取到的值直接写入到 <code>ptr(value)</code> 中完成复现。</p><blockquote><p>记一次使用 css预处理 ptr函数 的奇妙经历：当你因某些原因更换方案时，可直接重写 ptr函数 的 运算方式 达到一步到位的维护效果</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
          <category> WEB开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
